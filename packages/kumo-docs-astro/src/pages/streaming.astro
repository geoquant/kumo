---
import DocLayout from "../layouts/DocLayout.astro";
import ComponentSection from "../components/docs/ComponentSection.astro";
import CodeBlock from "../components/docs/CodeBlock.astro";
import Callout from "../components/docs/Callout.astro";
import { StreamingDemo } from "../components/demos/StreamingDemo";
---

<DocLayout
  title="Streaming UI"
  description="Render AI-generated UI from JSON using Kumo's auto-generated schemas. Enable progressive rendering as LLM responses stream in."
>
  <!-- Live Demo -->
  <ComponentSection>
    <h2 class="mb-4 text-2xl font-bold">Live Demo</h2>
    <p class="mb-4 text-kumo-strong">
      Ask the AI to generate UI using Kumo components. The response streams in
      real-time as JSONL patches, rendering live Kumo components as tokens arrive.
    </p>
    <StreamingDemo client:load />
  </ComponentSection>

  <!-- Quick Start -->
  <ComponentSection>
    <h2 class="mb-4 text-2xl font-bold">Quick Start</h2>
    <p class="mb-4 text-kumo-strong">
      Stream AI-generated Kumo UI in three steps: parse JSONL, apply RFC 6902 patches, render.
    </p>
    <CodeBlock
      code={`import { useUITree, createJsonlParser } from "@cloudflare/kumo/streaming";
import { UITreeRenderer } from "@cloudflare/kumo/generative";

function StreamingUI() {
  const { tree, applyPatches, reset } = useUITree({ batchPatches: true });

  async function startStream(prompt: string) {
    reset();
    const parser = createJsonlParser();
    const res = await fetch("/api/chat", {
      method: "POST",
      body: JSON.stringify({ message: prompt }),
    });

    const reader = res.body!.getReader();
    const decoder = new TextDecoder();

    for (;;) {
      const { done, value } = await reader.read();
      if (done) break;
      const ops = parser.push(decoder.decode(value, { stream: true }));
      if (ops.length > 0) applyPatches(ops);
    }

    // Flush remaining buffer
    const remaining = parser.flush();
    if (remaining.length > 0) applyPatches(remaining);
  }

  return <UITreeRenderer tree={tree} streaming={true} />;
}`}
      lang="tsx"
    />
    <div class="mt-4">
      <h3 class="mb-2 text-lg font-semibold">What's happening</h3>
      <ul class="mt-2 list-inside list-disc space-y-1 text-kumo-strong">
        <li><strong>useUITree</strong> — manages UITree state, applies patches via functional setState</li>
        <li><strong>createJsonlParser</strong> — parses newline-delimited JSON into RFC 6902 patch ops</li>
        <li><strong>UITreeRenderer</strong> — maps UITree elements to real Kumo React components</li>
        <li><strong>batchPatches</strong> — coalesces multiple patches into a single React render</li>
      </ul>
    </div>
  </ComponentSection>

  <!-- UMD / HTML -->
  <ComponentSection>
    <h2 class="mb-4 text-2xl font-bold">UMD / HTML Usage</h2>
    <p class="mb-4 text-kumo-strong">
      For non-React environments, the loadable UMD bundle exposes <code>window.CloudflareKumo</code>
      with a zero-framework API. React is bundled inside — the host page needs only a
      <code>&lt;script&gt;</code> tag and a container <code>&lt;div&gt;</code>.
    </p>
    <CodeBlock
      code={`<link rel="stylesheet" href="@cloudflare/kumo/loadable/style.css" />
<script src="@cloudflare/kumo/loadable/kumo-loadable.umd.js"><\/script>

<div id="my-ui"></div>

<script>
  const { CloudflareKumo } = window;

  // Optional: set theme
  CloudflareKumo.setTheme("dark");

  // Apply patches from your streaming source
  const parser = CloudflareKumo.createParser();

  eventSource.onmessage = (e) => {
    const ops = parser.push(e.data);
    if (ops.length > 0) {
      CloudflareKumo.applyPatchesBatched(ops, "my-ui");
    }
  };

  // Or render a complete tree at once
  CloudflareKumo.renderTree(
    { root: "card", elements: { card: { key: "card", type: "Surface", props: {}, children: [] } } },
    "my-ui"
  );
<\/script>`}
      lang="html"
    />
    <div class="mt-4">
      <h3 class="mb-2 text-lg font-semibold">API Reference</h3>
      <div class="overflow-x-auto">
        <table class="min-w-full text-sm">
          <thead>
            <tr class="border-b border-kumo-line">
              <th class="py-2 pr-4 text-left font-medium">Method</th>
              <th class="py-2 text-left font-medium">Description</th>
            </tr>
          </thead>
          <tbody class="text-kumo-strong">
            <tr class="border-b border-kumo-line">
              <td class="py-2 pr-4"><code>applyPatch(op, id)</code></td>
              <td class="py-2">Apply one RFC 6902 patch, re-render</td>
            </tr>
            <tr class="border-b border-kumo-line">
              <td class="py-2 pr-4"><code>applyPatches(ops, id)</code></td>
              <td class="py-2">Batch patches, single render</td>
            </tr>
            <tr class="border-b border-kumo-line">
              <td class="py-2 pr-4"><code>applyPatchesBatched(ops, id)</code></td>
              <td class="py-2">Batch patches, coalesced rAF render</td>
            </tr>
            <tr class="border-b border-kumo-line">
              <td class="py-2 pr-4"><code>renderTree(tree, id)</code></td>
              <td class="py-2">Replace entire UITree at once</td>
            </tr>
            <tr class="border-b border-kumo-line">
              <td class="py-2 pr-4"><code>createParser()</code></td>
              <td class="py-2">Create JSONL streaming parser</td>
            </tr>
            <tr class="border-b border-kumo-line">
              <td class="py-2 pr-4"><code>setTheme(mode)</code></td>
              <td class="py-2">Switch light/dark theme</td>
            </tr>
            <tr class="border-b border-kumo-line">
              <td class="py-2 pr-4"><code>getTree(id)</code></td>
              <td class="py-2">Read current UITree state</td>
            </tr>
            <tr class="border-b border-kumo-line">
              <td class="py-2 pr-4"><code>subscribeTree(id, cb)</code></td>
              <td class="py-2">Subscribe to UITree changes</td>
            </tr>
            <tr class="border-b border-kumo-line">
              <td class="py-2 pr-4"><code>dispatchAction(event, id)</code></td>
              <td class="py-2">Dispatch action from registry</td>
            </tr>
            <tr class="border-b border-kumo-line">
              <td class="py-2 pr-4"><code>reset(id)</code></td>
              <td class="py-2">Clear state and unmount</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
    <Callout type="info">
      The loadable bundle uses shadow DOM isolation by default for style encapsulation.
      Pass a container ID to scope each independent UI instance.
    </Callout>
  </ComponentSection>

  <!-- Component Map -->
  <ComponentSection>
    <h2 class="mb-4 text-2xl font-bold">Component Map</h2>
    <p class="mb-4 text-kumo-strong">
      The generative module maps UITree <code>type</code> strings to Kumo React components.
      This map is auto-generated from the component registry to stay in sync.
    </p>
    <div class="grid gap-4 md:grid-cols-2">
      <div class="rounded-lg border border-kumo-line bg-kumo-elevated p-4">
        <h3 class="mb-2 font-semibold">Direct Components</h3>
        <p class="mb-2 text-xs text-kumo-subtle">1:1 mapping to Kumo exports</p>
        <div class="flex flex-wrap gap-1.5">
          {["Badge", "Banner", "Breadcrumbs", "Button", "ClipboardText", "Cluster", "Code",
            "Empty", "Field", "Grid", "Label", "Link", "Loader", "Meter", "Radio",
            "Stack", "Table", "Text"].map(name => (
            <code class="rounded bg-kumo-control px-1.5 py-0.5 text-xs">{name}</code>
          ))}
        </div>
      </div>
      <div class="rounded-lg border border-kumo-line bg-kumo-elevated p-4">
        <h3 class="mb-2 font-semibold">Stateful Wrappers</h3>
        <p class="mb-2 text-xs text-kumo-subtle">Adds internal state for controlled-only components</p>
        <div class="flex flex-wrap gap-1.5">
          {["Checkbox", "Collapsible", "Select", "Switch", "Tabs"].map(name => (
            <code class="rounded bg-kumo-control px-1.5 py-0.5 text-xs">{name}</code>
          ))}
        </div>
      </div>
      <div class="rounded-lg border border-kumo-line bg-kumo-elevated p-4">
        <h3 class="mb-2 font-semibold">Generative Wrappers</h3>
        <p class="mb-2 text-xs text-kumo-subtle">Sensible defaults for AI context</p>
        <div class="flex flex-wrap gap-1.5">
          {["Surface", "Input", "InputArea", "CloudflareLogo", "Select"].map(name => (
            <code class="rounded bg-kumo-control px-1.5 py-0.5 text-xs">{name}</code>
          ))}
        </div>
      </div>
      <div class="rounded-lg border border-kumo-line bg-kumo-elevated p-4">
        <h3 class="mb-2 font-semibold">Sub-Component Aliases</h3>
        <p class="mb-2 text-xs text-kumo-subtle">Flattened names for LLM output</p>
        <div class="flex flex-wrap gap-1.5">
          {["TableHeader", "TableHead", "TableBody", "TableRow", "TableCell", "TableFooter",
            "BreadcrumbsLink", "BreadcrumbsCurrent", "SelectOption", "GridItem"].map(name => (
            <code class="rounded bg-kumo-control px-1.5 py-0.5 text-xs">{name}</code>
          ))}
        </div>
      </div>
    </div>
    <div class="mt-4 text-sm text-kumo-strong">
      <strong>Type aliases:</strong> <code>Textarea</code> maps to <code>InputArea</code>,
      <code>RadioGroup</code> maps to <code>Radio</code>.
      <code>Div</code> is a synthetic container type rendered as a plain <code>&lt;div&gt;</code>.
    </div>
    <Callout type="info">
      The component map and drift detection tests are auto-generated via
      <code>pnpm codegen:registry</code>. Run it after modifying component props or adding new components.
    </Callout>
  </ComponentSection>

  <!-- System Prompt -->
  <ComponentSection>
    <h2 class="mb-4 text-2xl font-bold">System Prompt Generation</h2>
    <p class="mb-4 text-kumo-strong">
      The catalog's <code>generatePrompt()</code> builds a complete system prompt for LLMs,
      including component documentation, JSONL/RFC 6902 format instructions, design rules,
      and working examples. It's derived from the component registry — always in sync.
    </p>
    <CodeBlock
      code={`import { createKumoCatalog, initCatalog } from "@cloudflare/kumo/catalog";

const catalog = createKumoCatalog();
await initCatalog(catalog);

// Full prompt with all components, examples, and format instructions
const prompt = catalog.generatePrompt();

// Subset of components only
const focused = catalog.generatePrompt({
  components: ["Button", "Input", "Surface", "Text"],
});

// Skip examples to reduce token count
const compact = catalog.generatePrompt({
  includeExamples: false,
  maxPropsPerComponent: 5,
});`}
      lang="ts"
    />
    <div class="mt-4">
      <h3 class="mb-2 text-lg font-semibold">What the prompt includes</h3>
      <ul class="mt-2 list-inside list-disc space-y-1 text-kumo-strong">
        <li><strong>Component docs</strong> — props grouped by category (Layout, Content, Interactive, etc.)</li>
        <li><strong>Prop scoring</strong> — top 10 props per component, ranked by relevance (required, enum, common names)</li>
        <li><strong>JSONL format</strong> — how the LLM should emit newline-delimited JSON patch ops</li>
        <li><strong>RFC 6902 schema</strong> — the UITree structure, element format, and patch semantics</li>
        <li><strong>Design rules</strong> — accessibility, semantic grouping, no emoji in content</li>
        <li><strong>Working examples</strong> — counter UI and form examples the LLM can learn from</li>
        <li><strong>Action system</strong> — built-in actions the LLM can attach to elements</li>
      </ul>
    </div>
    <Callout type="info">
      The full prompt is under 15K tokens. Use the <code>components</code> option to narrow it
      for domain-specific use cases.
    </Callout>
  </ComponentSection>

  <!-- Action System -->
  <ComponentSection>
    <h2 class="mb-4 text-2xl font-bold">Action System</h2>
    <p class="mb-4 text-kumo-strong">
      The streaming action system handles user interactions with AI-generated UI. Built-in
      actions cover common patterns; the host can extend with custom handlers.
    </p>
    <div class="overflow-x-auto">
      <table class="min-w-full text-sm">
        <thead>
          <tr class="border-b border-kumo-line">
            <th class="py-2 pr-4 text-left font-medium">Action</th>
            <th class="py-2 pr-4 text-left font-medium">Trigger</th>
            <th class="py-2 text-left font-medium">Effect</th>
          </tr>
        </thead>
        <tbody class="text-kumo-strong">
          <tr class="border-b border-kumo-line">
            <td class="py-2 pr-4"><code>increment</code></td>
            <td class="py-2 pr-4">Button click</td>
            <td class="py-2">Increments a numeric value at a JSON Pointer path</td>
          </tr>
          <tr class="border-b border-kumo-line">
            <td class="py-2 pr-4"><code>decrement</code></td>
            <td class="py-2 pr-4">Button click</td>
            <td class="py-2">Decrements a numeric value at a JSON Pointer path</td>
          </tr>
          <tr class="border-b border-kumo-line">
            <td class="py-2 pr-4"><code>submit_form</code></td>
            <td class="py-2 pr-4">Button click</td>
            <td class="py-2">Collects runtime form values and sends as a message</td>
          </tr>
          <tr class="border-b border-kumo-line">
            <td class="py-2 pr-4"><code>navigate</code></td>
            <td class="py-2 pr-4">Link / button click</td>
            <td class="py-2">Opens URL (http/https/relative only — javascript: blocked)</td>
          </tr>
        </tbody>
      </table>
    </div>
    <CodeBlock
      code={`import {
  useUITree,
  BUILTIN_HANDLERS,
  dispatchAction,
  processActionResult,
  type ActionEvent,
  type JsonPatchOp,
} from "@cloudflare/kumo/streaming";
import { UITreeRenderer } from "@cloudflare/kumo/generative";

function InteractiveUI() {
  const { tree, applyPatches } = useUITree({ batchPatches: true });

  function handleAction(event: ActionEvent) {
    const result = dispatchAction(BUILTIN_HANDLERS, event, tree);
    if (!result) return;

    processActionResult(result, {
      applyPatches: (patches: readonly JsonPatchOp[]) => applyPatches(patches),
      sendMessage: (msg: string) => console.log("Send:", msg),
      openExternal: (url: string) => window.open(url),
    });
  }

  return (
    <UITreeRenderer
      tree={tree}
      streaming={false}
      onAction={handleAction}
    />
  );
}`}
      lang="tsx"
    />
    <div class="mt-4">
      <h3 class="mb-2 text-lg font-semibold">URL Security</h3>
      <p class="text-kumo-strong">
        The <code>navigate</code> action enforces a URL allowlist: only <code>http://</code>,
        <code>https://</code>, and relative paths are permitted.
        <code>javascript:</code>, <code>data:</code>, <code>file:</code>, and
        protocol-relative URLs are blocked and logged as warnings.
      </p>
    </div>
  </ComponentSection>

  <!-- Divider: existing catalog docs below -->
  <div class="my-8 border-t border-kumo-line"></div>

  <!-- Existing: Overview -->
  <ComponentSection>
    <h2 class="mb-4 text-2xl font-bold">Catalog Overview</h2>
    <p class="mb-4 text-kumo-strong">
      The Kumo catalog module enables rendering UI from JSON structures, designed specifically for
      AI-generated interfaces. It provides runtime validation, data binding, conditional rendering,
      and action handling for JSON-based UI trees.
    </p>
    <div class="my-6 rounded-lg border border-kumo-brand/30 bg-kumo-brand/5 p-4">
      <h3 class="mb-2 font-semibold text-kumo-brand">Schemas Derived from Your Codebase</h3>
      <p class="text-sm text-kumo-strong">
        Unlike approaches that require maintaining separate schema definitions, Kumo automatically
        derives validation schemas from your actual component TypeScript types. When you update a
        component's props, the validation schemas update automatically via the component registry
        codegen process. No manual synchronization required - your schemas are always in sync with
        your components.
      </p>
    </div>
    <Callout type="info">
      Schemas are auto-generated in <code>@cloudflare/kumo/ai/schemas</code> from component TypeScript
      types. Run <code>pnpm codegen:registry</code> after modifying component props to regenerate.
    </Callout>
  </ComponentSection>

  <ComponentSection>
    <h2 class="mb-4 text-2xl font-bold">How It Works</h2>
    <p class="mb-4 text-kumo-strong">
      The catalog module uses a pipeline that extracts component metadata from your TypeScript
      source code:
    </p>
    <div class="overflow-x-auto">
      <div class="flex items-center gap-2 text-sm text-kumo-strong whitespace-nowrap py-4">
        <div class="rounded bg-kumo-control px-3 py-2 border border-kumo-line">Component TSX</div>
        <span class="text-kumo-subtle">→</span>
        <div class="rounded bg-kumo-control px-3 py-2 border border-kumo-line">TypeScript Types</div>
        <span class="text-kumo-subtle">→</span>
        <div class="rounded bg-kumo-control px-3 py-2 border border-kumo-line">Codegen Script</div>
        <span class="text-kumo-subtle">→</span>
        <div class="rounded bg-kumo-brand/10 px-3 py-2 border border-kumo-brand/30 text-kumo-brand">Zod Schemas</div>
      </div>
    </div>
    <p class="mt-4 text-kumo-strong">
      The generated schemas in <code>ai/schemas.ts</code> include:
    </p>
    <ul class="mt-2 list-inside list-disc space-y-1 text-kumo-strong">
      <li>Props schemas for each component (e.g., <code>ButtonPropsSchema</code>)</li>
      <li>Enum values for variant props</li>
      <li>UI element and tree structure schemas</li>
      <li>Dynamic value, visibility, and action schemas</li>
    </ul>
  </ComponentSection>

  <ComponentSection>
    <h2 class="mb-4 text-2xl font-bold">Installation</h2>
    <CodeBlock
      code={`import {
  createKumoCatalog,
  initCatalog,
  resolveProps,
  evaluateVisibility,
} from "@cloudflare/kumo/catalog";`}
      lang="ts"
    />
  </ComponentSection>

  <ComponentSection>
    <h2 class="mb-4 text-2xl font-bold">Creating a Catalog</h2>
    <p class="mb-4 text-kumo-strong">
      Create a catalog instance that validates AI-generated JSON against the auto-generated schemas:
    </p>
    <CodeBlock
      code={`import { createKumoCatalog, initCatalog } from "@cloudflare/kumo/catalog";

// Create a catalog with optional actions
const catalog = createKumoCatalog({
  actions: {
    submit_form: { description: "Submit the current form" },
    delete_item: { description: "Delete the selected item" },
  },
});

// Initialize schemas (required before sync validation)
await initCatalog(catalog);

// Validate AI-generated JSON
const result = catalog.validateTree(aiGeneratedJson);
if (result.success) {
  // Render the validated tree
  renderTree(result.data);
}`}
      lang="ts"
    />
  </ComponentSection>

  <ComponentSection>
    <h2 class="mb-4 text-2xl font-bold">UI Tree Format</h2>
    <p class="mb-4 text-kumo-strong">
      The UI tree uses a flat structure optimized for LLM generation and streaming. Elements
      reference each other by key rather than nesting, enabling progressive rendering as
      elements stream in.
    </p>
    <CodeBlock
      code={`{
  "root": "card-1",
  "elements": {
    "card-1": {
      "key": "card-1",
      "type": "Surface",
      "props": { "className": "p-4" },
      "children": ["heading-1", "text-1", "button-1"]
    },
    "heading-1": {
      "key": "heading-1",
      "type": "Text",
      "props": {
        "variant": "heading2",
        "children": "Welcome"
      },
      "parentKey": "card-1"
    },
    "text-1": {
      "key": "text-1",
      "type": "Text",
      "props": {
        "children": { "path": "/user/name" }
      },
      "parentKey": "card-1"
    },
    "button-1": {
      "key": "button-1",
      "type": "Button",
      "props": {
        "variant": "primary",
        "children": "Get Started"
      },
      "parentKey": "card-1",
      "action": {
        "name": "submit_form"
      }
    }
  }
}`}
      lang="json"
    />
    <div class="mt-4 text-kumo-strong">
      <strong>Why a flat structure?</strong>
      <ul class="mt-2 list-inside list-disc space-y-1">
        <li>Elements can be rendered as soon as they arrive (streaming)</li>
        <li>Easy updates without deep tree traversal</li>
        <li>Simple serialization/deserialization</li>
        <li>Natural fit for how LLMs generate token-by-token</li>
      </ul>
    </div>
  </ComponentSection>

  <ComponentSection>
    <h2 class="mb-4 text-2xl font-bold">Dynamic Values (Data Binding)</h2>
    <p class="mb-4 text-kumo-strong">
      Props can reference values from a data model using JSON Pointer paths. This allows the AI
      to declare data bindings that your application resolves at render time.
    </p>
    <CodeBlock
      code={`import { resolveProps, resolveDynamicValue } from "@cloudflare/kumo/catalog";

// Data model backing the UI
const dataModel = {
  user: {
    name: "Alice",
    isAdmin: true,
  },
  items: [
    { id: 1, title: "First Item" },
    { id: 2, title: "Second Item" },
  ],
};

// AI-generated props with dynamic references
const props = {
  children: { path: "/user/name" },
  disabled: false,
};

// Resolve all dynamic values
const resolved = resolveProps(props, dataModel);
// { children: "Alice", disabled: false }

// Or resolve individual values
const name = resolveDynamicValue({ path: "/user/name" }, dataModel);
// "Alice"`}
      lang="ts"
    />
  </ComponentSection>

  <ComponentSection>
    <h2 class="mb-4 text-2xl font-bold">Visibility Conditions</h2>
    <p class="mb-4 text-kumo-strong">
      Elements can be conditionally rendered based on data values, authentication state, or
      complex logic expressions.
    </p>
    <CodeBlock
      code={`import {
  evaluateVisibility,
  createVisibilityContext
} from "@cloudflare/kumo/catalog";

const ctx = createVisibilityContext(
  // Data model
  { user: { isAdmin: true, role: "editor" } },
  // Auth state
  { isSignedIn: true }
);

// Simple boolean
evaluateVisibility(true, ctx); // true

// Path check (truthy test)
evaluateVisibility({ path: "/user/isAdmin" }, ctx); // true

// Auth check
evaluateVisibility({ auth: "signedIn" }, ctx); // true
evaluateVisibility({ auth: "signedOut" }, ctx); // false

// Equality check
evaluateVisibility({
  eq: [{ path: "/user/role" }, "editor"]
}, ctx); // true

// Complex logic
evaluateVisibility({
  and: [
    { path: "/user/isAdmin" },
    { auth: "signedIn" },
    { gt: [{ path: "/items/length" }, 0] }
  ]
}, ctx);`}
      lang="ts"
    />
    <div class="mt-4">
      <h3 class="mb-2 text-lg font-semibold">Available Operators</h3>
      <div class="overflow-x-auto">
        <table class="min-w-full text-sm">
          <thead>
            <tr class="border-b border-kumo-line">
              <th class="py-2 pr-4 text-left font-medium">Operator</th>
              <th class="py-2 text-left font-medium">Description</th>
            </tr>
          </thead>
          <tbody class="text-kumo-strong">
            <tr class="border-b border-kumo-line">
              <td class="py-2 pr-4"><code>path</code></td>
              <td class="py-2">Truthy check on data path</td>
            </tr>
            <tr class="border-b border-kumo-line">
              <td class="py-2 pr-4"><code>auth</code></td>
              <td class="py-2">"signedIn" or "signedOut"</td>
            </tr>
            <tr class="border-b border-kumo-line">
              <td class="py-2 pr-4"><code>eq</code> / <code>neq</code></td>
              <td class="py-2">Equality / inequality comparison</td>
            </tr>
            <tr class="border-b border-kumo-line">
              <td class="py-2 pr-4"><code>gt</code> / <code>gte</code></td>
              <td class="py-2">Greater than / greater than or equal</td>
            </tr>
            <tr class="border-b border-kumo-line">
              <td class="py-2 pr-4"><code>lt</code> / <code>lte</code></td>
              <td class="py-2">Less than / less than or equal</td>
            </tr>
            <tr class="border-b border-kumo-line">
              <td class="py-2 pr-4"><code>and</code> / <code>or</code> / <code>not</code></td>
              <td class="py-2">Boolean logic combinators</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </ComponentSection>

  <ComponentSection>
    <h2 class="mb-4 text-2xl font-bold">Catalog Actions</h2>
    <p class="mb-4 text-kumo-strong">
      Elements can declare actions that your application handles. The AI describes the intent,
      and your handlers execute the logic.
    </p>
    <CodeBlock
      code={`// In your UI tree element
{
  "key": "delete-btn",
  "type": "Button",
  "props": {
    "variant": "destructive",
    "children": "Delete"
  },
  "action": {
    "name": "delete_item",
    "params": {
      "itemId": { "path": "/selected/id" }
    },
    "confirm": {
      "title": "Delete Item",
      "message": "Are you sure you want to delete this item?",
      "variant": "danger",
      "confirmLabel": "Delete",
      "cancelLabel": "Cancel"
    },
    "onSuccess": {
      "set": { "/selected": null }
    }
  }
}

// Register actions when creating the catalog
const catalog = createKumoCatalog({
  actions: {
    delete_item: {
      description: "Delete an item by ID",
      params: {
        itemId: { type: "string", description: "Item ID to delete" }
      }
    }
  }
});`}
      lang="ts"
    />
  </ComponentSection>

  <ComponentSection>
    <h2 class="mb-4 text-2xl font-bold">Validation</h2>
    <p class="mb-4 text-kumo-strong">
      The catalog validates AI-generated JSON against auto-generated Zod schemas derived from
      component TypeScript types.
    </p>
    <CodeBlock
      code={`// Validate a complete tree
const result = catalog.validateTree(aiJson);

if (result.success) {
  console.log("Valid tree:", result.data);
} else {
  console.error("Validation errors:", result.error);
  // [{ message: "Invalid enum value", path: ["elements", "btn-1", "props", "variant"] }]
}

// Validate a single element
const elementResult = catalog.validateElement({
  key: "btn-1",
  type: "Button",
  props: { variant: "primary" }
});

// Check available components
catalog.hasComponent("Button"); // true
catalog.hasComponent("Foobar"); // false

// List all component names
console.log(catalog.componentNames);
// ["Badge", "Banner", "Button", ...]`}
      lang="ts"
    />
  </ComponentSection>

  <ComponentSection>
    <h2 class="mb-4 text-2xl font-bold">Type Exports</h2>
    <p class="mb-4 text-kumo-strong">
      All types are exported for TypeScript integration:
    </p>
    <CodeBlock
      code={`import type {
  // Core types
  UIElement,
  UITree,
  DynamicValue,
  DynamicString,
  DynamicNumber,
  DynamicBoolean,

  // Visibility
  VisibilityCondition,
  LogicExpression,

  // Actions
  Action,
  ActionConfirm,
  ActionHandler,
  ActionHandlers,
  ActionDefinition,

  // Auth & Data
  AuthState,
  DataModel,

  // Catalog
  KumoCatalog,
  CatalogConfig,
  ValidationResult,
} from "@cloudflare/kumo/catalog";`}
      lang="ts"
    />
  </ComponentSection>

  <ComponentSection>
    <h2 class="mb-4 text-2xl font-bold">Key Benefits</h2>
    <div class="grid gap-4 md:grid-cols-2">
      <div class="rounded-lg border border-kumo-line bg-kumo-elevated p-4">
        <h3 class="mb-2 font-semibold">Auto-Generated Schemas</h3>
        <p class="text-sm text-kumo-strong">
          Validation schemas are derived directly from component TypeScript types.
          No separate schema definitions to maintain.
        </p>
      </div>
      <div class="rounded-lg border border-kumo-line bg-kumo-elevated p-4">
        <h3 class="mb-2 font-semibold">Always in Sync</h3>
        <p class="text-sm text-kumo-strong">
          When you update component props, the schemas update automatically via the
          component registry codegen process.
        </p>
      </div>
      <div class="rounded-lg border border-kumo-line bg-kumo-elevated p-4">
        <h3 class="mb-2 font-semibold">Streaming-Friendly</h3>
        <p class="text-sm text-kumo-strong">
          Flat tree structure enables progressive rendering as LLM responses stream in
          token-by-token.
        </p>
      </div>
      <div class="rounded-lg border border-kumo-line bg-kumo-elevated p-4">
        <h3 class="mb-2 font-semibold">Type Safety</h3>
        <p class="text-sm text-kumo-strong">
          Full TypeScript support with exported types for UIElement, UITree,
          DynamicValue, and more.
        </p>
      </div>
    </div>
  </ComponentSection>
</DocLayout>
