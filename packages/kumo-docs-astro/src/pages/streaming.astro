---
import DocLayout from "../layouts/DocLayout.astro";
import ComponentSection from "../components/docs/ComponentSection.astro";
import CodeBlock from "../components/docs/CodeBlock.astro";
import Callout from "../components/docs/Callout.astro";
import { StreamingDemo } from "../components/demos/_StreamingDemo";
---

<DocLayout
  title="Streaming"
  description="Render AI-generated UI from JSON using Kumo's auto-generated schemas. Enable progressive rendering as LLM responses stream in."
>
  <!-- Live Demo -->
  <ComponentSection>
    <h2 class="mb-4 text-2xl font-bold">Live Demo</h2>
    <p class="mb-4 text-kumo-strong">
      Ask the AI to generate UI using Kumo components. The response streams in
      real-time as JSONL patches, rendering live Kumo components as tokens arrive.
    </p>
    <StreamingDemo client:load />
  </ComponentSection>

  <!-- Quick Start -->
  <ComponentSection>
    <h2 class="mb-4 text-2xl font-bold">Quick Start</h2>
    <p class="mb-4 text-kumo-strong">
      Stream AI-generated Kumo UI in three steps: parse JSONL, apply RFC 6902 patches, render.
    </p>
    <CodeBlock
      code={`import {
  useUITree,
  useRuntimeValueStore,
  createJsonlParser,
} from "@cloudflare/kumo/streaming";
import { UITreeRenderer } from "@cloudflare/kumo/generative";

function StreamingUI() {
  const { tree, applyPatches, reset } = useUITree({ batchPatches: true });
  const runtimeValueStore = useRuntimeValueStore();

  async function startStream(prompt: string) {
    reset();
    const parser = createJsonlParser();
    const res = await fetch("/api/chat", {
      method: "POST",
      headers: { "Content-Type": "application/json", Accept: "text/event-stream" },
      body: JSON.stringify({ message: prompt }),
    });

    const reader = res.body?.getReader();
    if (!reader) return;
    const decoder = new TextDecoder();
    let buffer = "";

    for (;;) {
      const { done, value } = await reader.read();
      if (done) break;

      buffer += decoder.decode(value, { stream: true }).replace(/\r/g, "");
      for (;;) {
        const newline = buffer.indexOf("\n");
        if (newline === -1) break;
        const line = buffer.slice(0, newline).trim();
        buffer = buffer.slice(newline + 1);

        if (!line.startsWith("data:")) continue;
        const payload = line.slice("data:".length).trimStart();
        if (payload === "[DONE]") return;

        const parsed: unknown = JSON.parse(payload);
        let token = "";
        if (typeof parsed === "object" && parsed !== null) {
          const obj = parsed as Record<string, unknown>;
          if (typeof obj.response === "string") token = obj.response;
        }

        const ops = parser.push(token);
        if (ops.length > 0) applyPatches(ops);
      }
    }

    // Flush remaining buffer
    const remaining = parser.flush();
    if (remaining.length > 0) applyPatches(remaining);
  }

  return (
    <UITreeRenderer
      tree={tree}
      streaming={true}
      runtimeValueStore={runtimeValueStore}
    />
  );
}`}
      lang="tsx"
    />
    <div class="mt-4">
      <h3 class="mb-2 text-lg font-semibold">What's happening</h3>
      <ul class="mt-2 list-inside list-disc space-y-1 text-kumo-strong">
        <li><strong>useUITree</strong> — manages UITree state, applies patches via functional setState</li>
        <li><strong>useRuntimeValueStore</strong> — captures form field values (Input, Select, etc.) for <code>submit_form</code> actions</li>
        <li><strong>createJsonlParser</strong> — parses newline-delimited JSON into RFC 6902 patch ops</li>
        <li><strong>UITreeRenderer</strong> — maps UITree elements to real Kumo React components</li>
        <li><strong>batchPatches</strong> — coalesces multiple patches into a single React render</li>
      </ul>
    </div>
  </ComponentSection>

  <!-- UMD / HTML -->
  <ComponentSection>
    <h2 class="mb-4 text-2xl font-bold">UMD / HTML Usage</h2>
    <p class="mb-4 text-kumo-strong">
      For non-React environments, the loadable UMD bundle exposes <code>window.CloudflareKumo</code>
      with a zero-framework API. React is bundled inside — the host page needs only a
      <code>&lt;script&gt;</code> tag and a container <code>&lt;div&gt;</code>.
    </p>
    <CodeBlock
      code={`<link rel="stylesheet" href="@cloudflare/kumo/loadable/style.css" />
<script src="@cloudflare/kumo/loadable/kumo-loadable.umd.js"><\/script>

<div id="my-ui"></div>

<script>
  const { CloudflareKumo } = window;

  // Optional: set theme
  CloudflareKumo.setTheme("dark");

  // Apply patches from your streaming source
  const parser = CloudflareKumo.createParser();

  eventSource.onmessage = (e) => {
    const ops = parser.push(e.data);
    if (ops.length > 0) {
      CloudflareKumo.applyPatchesBatched(ops, "my-ui");
    }
  };

  // Or render a complete tree at once
  CloudflareKumo.renderTree(
    { root: "card", elements: { card: { key: "card", type: "Surface", props: {}, children: [] } } },
    "my-ui"
  );
<\/script>`}
      lang="html"
    />
    <div class="mt-4">
      <h3 class="mb-2 text-lg font-semibold">API Reference</h3>
      <div class="overflow-x-auto">
        <table class="min-w-full text-sm">
          <thead>
            <tr class="border-b border-kumo-line">
              <th class="py-2 pr-4 text-left font-medium">Method</th>
              <th class="py-2 text-left font-medium">Description</th>
            </tr>
          </thead>
          <tbody class="text-kumo-strong">
            <tr class="border-b border-kumo-line">
              <td class="py-2 pr-4"><code>applyPatch(op, id)</code></td>
              <td class="py-2">Apply one RFC 6902 patch, re-render</td>
            </tr>
            <tr class="border-b border-kumo-line">
              <td class="py-2 pr-4"><code>applyPatches(ops, id)</code></td>
              <td class="py-2">Batch patches, single render</td>
            </tr>
            <tr class="border-b border-kumo-line">
              <td class="py-2 pr-4"><code>applyPatchesBatched(ops, id)</code></td>
              <td class="py-2">Batch patches, coalesced rAF render</td>
            </tr>
            <tr class="border-b border-kumo-line">
              <td class="py-2 pr-4"><code>renderTree(tree, id)</code></td>
              <td class="py-2">Replace entire UITree at once</td>
            </tr>
            <tr class="border-b border-kumo-line">
              <td class="py-2 pr-4"><code>createParser()</code></td>
              <td class="py-2">Create JSONL streaming parser</td>
            </tr>
            <tr class="border-b border-kumo-line">
              <td class="py-2 pr-4"><code>setTheme(mode)</code></td>
              <td class="py-2">Switch light/dark theme</td>
            </tr>
            <tr class="border-b border-kumo-line">
              <td class="py-2 pr-4"><code>getTree(id)</code></td>
              <td class="py-2">Read current UITree state</td>
            </tr>
            <tr class="border-b border-kumo-line">
              <td class="py-2 pr-4"><code>subscribeTree(id, cb)</code></td>
              <td class="py-2">Subscribe to UITree changes</td>
            </tr>
            <tr class="border-b border-kumo-line">
              <td class="py-2 pr-4"><code>dispatchAction(event, id)</code></td>
              <td class="py-2">Dispatch action through built-in handlers</td>
            </tr>
            <tr class="border-b border-kumo-line">
              <td class="py-2 pr-4"><code>processActionResult(result, callbacks)</code></td>
              <td class="py-2">Route action result to applyPatches / sendMessage / openExternal</td>
            </tr>
            <tr class="border-b border-kumo-line">
              <td class="py-2 pr-4"><code>getRuntimeValues(id)</code></td>
              <td class="py-2">Read captured form input values</td>
            </tr>
            <tr class="border-b border-kumo-line">
              <td class="py-2 pr-4"><code>subscribeRuntimeValues(id, cb)</code></td>
              <td class="py-2">Subscribe to form value changes</td>
            </tr>
            <tr class="border-b border-kumo-line">
              <td class="py-2 pr-4"><code>onAction(handler)</code></td>
              <td class="py-2">Subscribe to all action events (JS callback alternative to CustomEvent)</td>
            </tr>
            <tr class="border-b border-kumo-line">
              <td class="py-2 pr-4"><code>reset(id)</code></td>
              <td class="py-2">Clear state and unmount</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
    <Callout type="info">
      The loadable bundle uses shadow DOM isolation by default for style encapsulation.
      Pass a container ID to scope each independent UI instance.
    </Callout>
  </ComponentSection>

  <!-- Component Map -->
  <ComponentSection>
    <h2 class="mb-4 text-2xl font-bold">Component Map</h2>
    <p class="mb-4 text-kumo-strong">
      The generative module maps UITree <code>type</code> strings to Kumo React components.
      This map is auto-generated from the component registry to stay in sync.
    </p>
    <div class="grid gap-4 md:grid-cols-2">
      <div class="rounded-lg border border-kumo-line bg-kumo-elevated p-4">
        <h3 class="mb-2 font-semibold">Direct Components</h3>
        <p class="mb-2 text-xs text-kumo-subtle">1:1 mapping to Kumo exports</p>
        <div class="flex flex-wrap gap-1.5">
          {["Badge", "Banner", "Breadcrumbs", "Button", "ClipboardText", "Cluster", "Code",
            "Empty", "Field", "Grid", "Label", "Link", "Loader", "Meter", "Radio",
            "Stack", "Table", "Text"].map(name => (
            <code class="rounded bg-kumo-control px-1.5 py-0.5 text-xs">{name}</code>
          ))}
        </div>
      </div>
      <div class="rounded-lg border border-kumo-line bg-kumo-elevated p-4">
        <h3 class="mb-2 font-semibold">Stateful Wrappers</h3>
        <p class="mb-2 text-xs text-kumo-subtle">Adds internal state for controlled-only components</p>
        <div class="flex flex-wrap gap-1.5">
          {["Checkbox", "Collapsible", "Select", "Switch", "Tabs"].map(name => (
            <code class="rounded bg-kumo-control px-1.5 py-0.5 text-xs">{name}</code>
          ))}
        </div>
      </div>
      <div class="rounded-lg border border-kumo-line bg-kumo-elevated p-4">
        <h3 class="mb-2 font-semibold">Generative Wrappers</h3>
        <p class="mb-2 text-xs text-kumo-subtle">Sensible defaults for AI context</p>
        <div class="flex flex-wrap gap-1.5">
          {["Surface", "Input", "InputArea", "CloudflareLogo", "Select"].map(name => (
            <code class="rounded bg-kumo-control px-1.5 py-0.5 text-xs">{name}</code>
          ))}
        </div>
      </div>
      <div class="rounded-lg border border-kumo-line bg-kumo-elevated p-4">
        <h3 class="mb-2 font-semibold">Sub-Component Aliases</h3>
        <p class="mb-2 text-xs text-kumo-subtle">Flattened names for LLM output</p>
        <div class="flex flex-wrap gap-1.5">
          {["TableHeader", "TableHead", "TableBody", "TableRow", "TableCell", "TableFooter",
            "BreadcrumbsLink", "BreadcrumbsCurrent", "SelectOption", "GridItem"].map(name => (
            <code class="rounded bg-kumo-control px-1.5 py-0.5 text-xs">{name}</code>
          ))}
        </div>
      </div>
    </div>
    <div class="mt-4 text-sm text-kumo-strong">
      <strong>Type aliases:</strong> <code>Textarea</code> maps to <code>InputArea</code>,
      <code>RadioGroup</code> maps to <code>Radio</code>.
      <code>Div</code> is a synthetic container type rendered as a plain <code>&lt;div&gt;</code>.
    </div>
    <Callout type="info">
      The component map and drift detection tests are auto-generated via
      <code>pnpm codegen:registry</code>. Run it after modifying component props or adding new components.
    </Callout>
  </ComponentSection>

  <!-- Custom Components -->
  <ComponentSection>
    <h2 class="mb-4 text-2xl font-bold">Custom Components</h2>
    <p class="mb-4 text-kumo-strong">
      Extend UITreeRenderer with your own React components so LLM-generated UI can
      include domain-specific elements (charts, maps, custom widgets) alongside
      built-in Kumo components. The extension model has three independent layers:
    </p>
    <div class="grid gap-4 md:grid-cols-3">
      <div class="rounded-lg border border-kumo-line bg-kumo-elevated p-4">
        <h3 class="mb-1 font-semibold">Render</h3>
        <p class="text-sm text-kumo-strong">
          Pass custom components to <code>UITreeRenderer</code> so
          it knows how to render new <code>type</code> strings.
        </p>
      </div>
      <div class="rounded-lg border border-kumo-line bg-kumo-elevated p-4">
        <h3 class="mb-1 font-semibold">Validation</h3>
        <p class="text-sm text-kumo-strong">
          Attach a Zod <code>propsSchema</code> to validate props at
          runtime through the same pipeline as built-in components.
        </p>
      </div>
      <div class="rounded-lg border border-kumo-line bg-kumo-elevated p-4">
        <h3 class="mb-1 font-semibold">Prompt</h3>
        <p class="text-sm text-kumo-strong">
          Provide <code>props</code> metadata so <code>generatePrompt()</code>
          includes your components in the LLM system prompt.
        </p>
      </div>
    </div>

    <h3 class="mb-2 mt-6 text-lg font-semibold">Quick Start (Render Only)</h3>
    <p class="mb-2 text-kumo-strong">
      The minimal path: define a component and pass it to <code>UITreeRenderer</code>.
      No validation or prompt generation — just rendering.
    </p>
    <CodeBlock
      code={`import { defineCustomComponent } from "@cloudflare/kumo/generative";
import { UITreeRenderer } from "@cloudflare/kumo/generative";
import type { CustomComponentDefinition } from "@cloudflare/kumo/catalog";

// Your domain component
function BarChart({ data, color }: { data: number[]; color?: string }) {
  return <svg>{/* chart rendering */}</svg>;
}

// Define outside the render path for stable identity
const barChart = defineCustomComponent({
  component: BarChart,
  description: "Renders a bar chart from numeric data",
});

const customComponents: Readonly<Record<string, CustomComponentDefinition>> = {
  BarChart: barChart,
};

// In your component
function App() {
  const { tree } = useUITree({ batchPatches: true });

  return (
    <UITreeRenderer
      tree={tree}
      streaming={true}
      customComponents={customComponents}
    />
  );
}`}
      lang="tsx"
    />

    <h3 class="mb-2 mt-6 text-lg font-semibold">Full Example (Validation + Prompt)</h3>
    <p class="mb-2 text-kumo-strong">
      For production use, add a Zod schema for runtime prop validation and prop
      metadata for LLM prompt generation:
    </p>
    <CodeBlock
      code={`import { z } from "zod";
import { defineCustomComponent } from "@cloudflare/kumo/generative";
import { UITreeRenderer } from "@cloudflare/kumo/generative";
import { createKumoCatalog, initCatalog } from "@cloudflare/kumo/catalog";
import type { CustomComponentDefinition } from "@cloudflare/kumo/catalog";

// Zod schema for runtime validation
const barChartSchema = z.object({
  data: z.array(z.number()),
  color: z.string().optional(),
  title: z.string().optional(),
});

const barChart = defineCustomComponent({
  component: BarChart,
  description: "Renders a bar chart from numeric data",
  // Runtime validation — same pipeline as built-in components
  propsSchema: barChartSchema,
  // Prompt metadata — tells the LLM what props are available
  props: {
    data: { type: "number[]", description: "Data points to plot" },
    color: { type: "string", description: "Bar fill color", optional: true },
    title: { type: "string", description: "Chart title", optional: true },
  },
  category: "Visualization",
});

const customComponents = { BarChart: barChart } as const;

// Create catalog with custom components for prompt generation
const catalog = createKumoCatalog({ customComponents });
await initCatalog(catalog);

// generatePrompt() now includes BarChart docs under "### Custom"
const prompt = catalog.generatePrompt();`}
      lang="tsx"
    />

    <h3 class="mb-2 mt-6 text-lg font-semibold">Caveats</h3>
    <ul class="mt-2 list-inside list-disc space-y-1 text-kumo-strong">
      <li>
        <strong>Define outside render</strong> — component definitions must be
        created outside React render functions. <code>defineCustomComponent</code>
        freezes the object, and <code>UITreeRenderer</code> memoises the merged map
        by identity.
      </li>
      <li>
        <strong>Consumer manages prompts</strong> — custom component docs are
        included in <code>generatePrompt()</code> output, but you are responsible
        for passing that prompt to your LLM.
      </li>
      <li>
        <strong>No auto-codegen</strong> — custom components are not added to
        <code>component-registry.json</code> or <code>ai/schemas.ts</code>.
        Those files only cover built-in Kumo components.
      </li>
    </ul>

    <h3 class="mb-2 mt-6 text-lg font-semibold">Security</h3>
    <ul class="mt-2 list-inside list-disc space-y-1 text-kumo-strong">
      <li>
        <strong>Props are sanitized</strong> — custom component props pass through
        the same <code>sanitizeProps()</code> pipeline as built-in components
        (event handlers and dangerous attributes are stripped).
      </li>
      <li>
        <strong>Component internals are your responsibility</strong> — Kumo
        sanitizes the props boundary, but what your component does with those
        props (e.g. rendering user-provided HTML) is outside the library's
        security scope.
      </li>
    </ul>
    <Callout type="info">
      When a custom component name collides with a built-in (e.g. naming yours
      <code>Button</code>), the custom component wins and a console warning is
      emitted in development. This is intentional — it lets you override built-ins
      when needed.
    </Callout>
  </ComponentSection>

  <!-- System Prompt -->
  <ComponentSection>
    <h2 class="mb-4 text-2xl font-bold">System Prompt Generation</h2>
    <p class="mb-4 text-kumo-strong">
      The catalog's <code>generatePrompt()</code> builds a complete system prompt for LLMs,
      including component documentation, JSONL/RFC 6902 format instructions, design rules,
      and working examples. It's derived from the component registry — always in sync.
    </p>
    <CodeBlock
      code={`import { createKumoCatalog, initCatalog } from "@cloudflare/kumo/catalog";

const catalog = createKumoCatalog();
await initCatalog(catalog);

// Full prompt with all components, examples, and format instructions
const prompt = catalog.generatePrompt();

// Subset of components only
const focused = catalog.generatePrompt({
  components: ["Button", "Input", "Surface", "Text"],
});

// Skip examples to reduce token count
const compact = catalog.generatePrompt({
  includeExamples: false,
  maxPropsPerComponent: 5,
});`}
      lang="ts"
    />
    <div class="mt-4">
      <h3 class="mb-2 text-lg font-semibold">What the prompt includes</h3>
      <ul class="mt-2 list-inside list-disc space-y-1 text-kumo-strong">
        <li><strong>Component docs</strong> — props grouped by category (Layout, Content, Interactive, etc.)</li>
        <li><strong>Prop scoring</strong> — top 10 props per component, ranked by relevance (required, enum, common names)</li>
        <li><strong>JSONL format</strong> — how the LLM should emit newline-delimited JSON patch ops</li>
        <li><strong>RFC 6902 schema</strong> — the UITree structure, element format, and patch semantics</li>
        <li><strong>Design rules</strong> — accessibility, semantic grouping, no emoji in content</li>
        <li><strong>Working examples</strong> — counter UI and form examples the LLM can learn from</li>
        <li><strong>Action system</strong> — built-in actions the LLM can attach to elements</li>
      </ul>
    </div>
    <Callout type="info">
      The full prompt is under 15K tokens. Use the <code>components</code> option to narrow it
      for domain-specific use cases.
    </Callout>
  </ComponentSection>

  <!-- Action System -->
  <ComponentSection>
    <h2 class="mb-4 text-2xl font-bold">Action System</h2>
    <p class="mb-4 text-kumo-strong">
      The streaming action system handles user interactions with AI-generated UI. Built-in
      actions cover common patterns; the host can extend with custom handlers.
    </p>
    <div class="overflow-x-auto">
      <table class="min-w-full text-sm">
        <thead>
          <tr class="border-b border-kumo-line">
            <th class="py-2 pr-4 text-left font-medium">Action</th>
            <th class="py-2 pr-4 text-left font-medium">Trigger</th>
            <th class="py-2 text-left font-medium">Effect</th>
          </tr>
        </thead>
        <tbody class="text-kumo-strong">
          <tr class="border-b border-kumo-line">
            <td class="py-2 pr-4"><code>increment</code></td>
            <td class="py-2 pr-4">Button click</td>
            <td class="py-2">Increments a numeric value at a JSON Pointer path</td>
          </tr>
          <tr class="border-b border-kumo-line">
            <td class="py-2 pr-4"><code>decrement</code></td>
            <td class="py-2 pr-4">Button click</td>
            <td class="py-2">Decrements a numeric value at a JSON Pointer path</td>
          </tr>
          <tr class="border-b border-kumo-line">
            <td class="py-2 pr-4"><code>submit_form</code></td>
            <td class="py-2 pr-4">Button click</td>
            <td class="py-2">Collects runtime form values and sends as a message</td>
          </tr>
          <tr class="border-b border-kumo-line">
            <td class="py-2 pr-4"><code>navigate</code></td>
            <td class="py-2 pr-4">Link / button click</td>
            <td class="py-2">Opens URL (http/https/relative only — javascript: blocked)</td>
          </tr>
        </tbody>
      </table>
    </div>
    <h3 class="mb-2 mt-6 text-lg font-semibold">React</h3>
    <p class="mb-2 text-kumo-strong">
      Wire <code>useRuntimeValueStore</code> to capture form field values, then connect
      <code>sendMessage</code> to your streaming function so <code>submit_form</code> feeds
      collected values back into the conversation.
    </p>
    <CodeBlock
      code={`import { useRef, useCallback } from "react";
import {
  useUITree,
  useRuntimeValueStore,
  BUILTIN_HANDLERS,
  dispatchAction,
  processActionResult,
  type ActionEvent,
  type JsonPatchOp,
  type UITree,
} from "@cloudflare/kumo/streaming";
import { UITreeRenderer } from "@cloudflare/kumo/generative";

function InteractiveUI() {
  const { tree, applyPatches, reset } = useUITree({ batchPatches: true });
  const runtimeValueStore = useRuntimeValueStore();

  // Refs prevent stale closures — the handleAction callback
  // captures the latest tree/applyPatches without re-subscribing.
  const treeRef = useRef<UITree>(tree);
  treeRef.current = tree;
  const applyPatchesRef = useRef(applyPatches);
  applyPatchesRef.current = applyPatches;

  const startStream = useCallback(async (prompt: string) => {
    reset();
    // ... your streaming logic (see Quick Start)
  }, [reset]);
  const startStreamRef = useRef(startStream);
  startStreamRef.current = startStream;

  function handleAction(event: ActionEvent) {
    const result = dispatchAction(
      BUILTIN_HANDLERS, event, treeRef.current
    );
    if (!result) return;

    processActionResult(result, {
      applyPatches: (patches: readonly JsonPatchOp[]) =>
        applyPatchesRef.current(patches),
      // submit_form calls sendMessage with collected form values —
      // wire it to start a new stream turn.
      sendMessage: (msg: string) => startStreamRef.current(msg),
      openExternal: (url: string, target?: string) =>
        window.open(url, target ?? "_blank"),
    });
  }

  return (
    <UITreeRenderer
      tree={tree}
      streaming={false}
      onAction={handleAction}
      runtimeValueStore={runtimeValueStore}
    />
  );
}`}
      lang="tsx"
    />

    <h3 class="mb-2 mt-6 text-lg font-semibold">UMD / HTML</h3>
    <p class="mb-2 text-kumo-strong">
      In UMD mode, actions fire as <code>CustomEvent</code>s on <code>window</code>.
      Listen for <code>kumo-action</code>, dispatch through the built-in registry,
      and process the result.
    </p>
    <CodeBlock
      code={`<script>
  const CONTAINER = "my-ui";

  // Listen for action events from the rendered UI
  window.addEventListener("kumo-action", function (e) {
    var detail = e.detail;

    // Dispatch through built-in handlers (increment, decrement, submit_form, navigate)
    var result = CloudflareKumo.dispatchAction(detail, CONTAINER);
    if (result == null) return;

    CloudflareKumo.processActionResult(result, {
      applyPatches: function (patches) {
        CloudflareKumo.applyPatches(patches, CONTAINER);
      },
      // submit_form calls sendMessage with collected form values —
      // wire it to start a new stream turn.
      sendMessage: function (content) {
        streamChat(content);
      },
    });
  });

  // React to runtime value changes (e.g. update a submit preview)
  CloudflareKumo.subscribeRuntimeValues(CONTAINER, function () {
    var values = CloudflareKumo.getRuntimeValues(CONTAINER);
    console.log("Current form values:", values);
  });
<\/script>`}
      lang="html"
    />

    <h3 class="mb-2 mt-6 text-lg font-semibold">Form Submission Flow</h3>
    <p class="mb-2 text-kumo-strong">
      When the LLM attaches a <code>submit_form</code> action to a Button, clicking it
      triggers a data collection pipeline:
    </p>
    <ol class="mt-2 list-inside list-decimal space-y-1 text-kumo-strong">
      <li><strong>Capture</strong> — Input/Textarea/Select/Checkbox changes are written to the <code>runtimeValueStore</code> as users type</li>
      <li><strong>Snapshot</strong> — On submit click, all captured values are injected into <code>event.context.runtimeValues</code></li>
      <li><strong>Dispatch</strong> — <code>dispatchAction</code> matches <code>submit_form</code>, collects scoped field values, returns a <code>MessageResult</code></li>
      <li><strong>Send</strong> — <code>processActionResult</code> calls your <code>sendMessage</code> callback with the serialized form payload</li>
    </ol>
    <p class="mt-2 text-kumo-strong">
      The payload sent to <code>sendMessage</code> is a JSON string containing
      <code>actionName</code>, <code>sourceKey</code>, and <code>fields</code> (the collected input values).
      Your server can parse this to process the form submission or feed it back into the LLM conversation.
    </p>

    <div class="mt-4">
      <h3 class="mb-2 text-lg font-semibold">URL Security</h3>
      <p class="text-kumo-strong">
        The <code>navigate</code> action enforces a URL allowlist: only <code>http://</code>,
        <code>https://</code>, and relative paths are permitted.
        <code>javascript:</code>, <code>data:</code>, <code>file:</code>, and
        protocol-relative URLs are blocked and logged as warnings.
      </p>
    </div>
  </ComponentSection>

  <!-- Divider: existing catalog docs below -->
  <div class="my-8 border-t border-kumo-line"></div>

  <!-- Existing: Overview -->
  <ComponentSection>
    <h2 class="mb-4 text-2xl font-bold">Catalog Overview</h2>
    <p class="mb-4 text-kumo-strong">
      The Kumo catalog module enables rendering UI from JSON structures, designed specifically for
      AI-generated interfaces. It provides runtime validation, data binding, conditional rendering,
      and action handling for JSON-based UI trees.
    </p>
    <div class="my-6 rounded-lg border border-kumo-brand/30 bg-kumo-brand/5 p-4">
      <h3 class="mb-2 font-semibold text-kumo-brand">Schemas Derived from Your Codebase</h3>
      <p class="text-sm text-kumo-strong">
        Unlike approaches that require maintaining separate schema definitions, Kumo automatically
        derives validation schemas from your actual component TypeScript types. When you update a
        component's props, the validation schemas update automatically via the component registry
        codegen process. No manual synchronization required - your schemas are always in sync with
        your components.
      </p>
    </div>
    <Callout type="info">
      Schemas are auto-generated in <code>@cloudflare/kumo/ai/schemas</code> from component TypeScript
      types. Run <code>pnpm codegen:registry</code> after modifying component props to regenerate.
    </Callout>
  </ComponentSection>

  <ComponentSection>
    <h2 class="mb-4 text-2xl font-bold">How It Works</h2>
    <p class="mb-4 text-kumo-strong">
      The catalog module uses a pipeline that extracts component metadata from your TypeScript
      source code:
    </p>
    <div class="overflow-x-auto">
      <div class="flex items-center gap-2 text-sm text-kumo-strong whitespace-nowrap py-4">
        <div class="rounded bg-kumo-control px-3 py-2 border border-kumo-line">Component TSX</div>
        <span class="text-kumo-subtle">→</span>
        <div class="rounded bg-kumo-control px-3 py-2 border border-kumo-line">TypeScript Types</div>
        <span class="text-kumo-subtle">→</span>
        <div class="rounded bg-kumo-control px-3 py-2 border border-kumo-line">Codegen Script</div>
        <span class="text-kumo-subtle">→</span>
        <div class="rounded bg-kumo-brand/10 px-3 py-2 border border-kumo-brand/30 text-kumo-brand">Zod Schemas</div>
      </div>
    </div>
    <p class="mt-4 text-kumo-strong">
      The generated schemas in <code>ai/schemas.ts</code> include:
    </p>
    <ul class="mt-2 list-inside list-disc space-y-1 text-kumo-strong">
      <li>Props schemas for each component (e.g., <code>ButtonPropsSchema</code>)</li>
      <li>Enum values for variant props</li>
      <li>UI element and tree structure schemas</li>
      <li>Dynamic value, visibility, and action schemas</li>
    </ul>
  </ComponentSection>

  <ComponentSection>
    <h2 class="mb-4 text-2xl font-bold">Installation</h2>
    <CodeBlock
      code={`import {
  createKumoCatalog,
  initCatalog,
  resolveProps,
  evaluateVisibility,
} from "@cloudflare/kumo/catalog";`}
      lang="ts"
    />
  </ComponentSection>

  <ComponentSection>
    <h2 class="mb-4 text-2xl font-bold">Creating a Catalog</h2>
    <p class="mb-4 text-kumo-strong">
      Create a catalog instance that validates AI-generated JSON against the auto-generated schemas:
    </p>
    <CodeBlock
      code={`import { createKumoCatalog, initCatalog } from "@cloudflare/kumo/catalog";

// Create a catalog with optional actions
const catalog = createKumoCatalog({
  actions: {
    submit_form: { description: "Submit the current form" },
    delete_item: { description: "Delete the selected item" },
  },
});

// Initialize schemas (required before sync validation)
await initCatalog(catalog);

// Validate AI-generated JSON
const result = catalog.validateTree(aiGeneratedJson);
if (result.success) {
  // Render the validated tree
  renderTree(result.data);
}`}
      lang="ts"
    />
  </ComponentSection>

  <ComponentSection>
    <h2 class="mb-4 text-2xl font-bold">UI Tree Format</h2>
    <p class="mb-4 text-kumo-strong">
      The UI tree uses a flat structure optimized for LLM generation and streaming. Elements
      reference each other by key rather than nesting, enabling progressive rendering as
      elements stream in.
    </p>
    <CodeBlock
      code={`{
  "root": "card-1",
  "elements": {
    "card-1": {
      "key": "card-1",
      "type": "Surface",
      "props": { "className": "p-4" },
      "children": ["heading-1", "text-1", "button-1"]
    },
    "heading-1": {
      "key": "heading-1",
      "type": "Text",
      "props": {
        "variant": "heading2",
        "children": "Welcome"
      },
      "parentKey": "card-1"
    },
    "text-1": {
      "key": "text-1",
      "type": "Text",
      "props": {
        "children": { "path": "/user/name" }
      },
      "parentKey": "card-1"
    },
    "button-1": {
      "key": "button-1",
      "type": "Button",
      "props": {
        "variant": "primary",
        "children": "Get Started"
      },
      "parentKey": "card-1",
      "action": {
        "name": "submit_form"
      }
    }
  }
}`}
      lang="json"
    />
    <div class="mt-4 text-kumo-strong">
      <strong>Why a flat structure?</strong>
      <ul class="mt-2 list-inside list-disc space-y-1">
        <li>Elements can be rendered as soon as they arrive (streaming)</li>
        <li>Easy updates without deep tree traversal</li>
        <li>Simple serialization/deserialization</li>
        <li>Natural fit for how LLMs generate token-by-token</li>
      </ul>
    </div>
  </ComponentSection>

  <ComponentSection>
    <h2 class="mb-4 text-2xl font-bold">Dynamic Values (Data Binding)</h2>
    <p class="mb-4 text-kumo-strong">
      Props can reference values from a data model using JSON Pointer paths. This allows the AI
      to declare data bindings that your application resolves at render time.
    </p>
    <CodeBlock
      code={`import { resolveProps, resolveDynamicValue } from "@cloudflare/kumo/catalog";

// Data model backing the UI
const dataModel = {
  user: {
    name: "Alice",
    isAdmin: true,
  },
  items: [
    { id: 1, title: "First Item" },
    { id: 2, title: "Second Item" },
  ],
};

// AI-generated props with dynamic references
const props = {
  children: { path: "/user/name" },
  disabled: false,
};

// Resolve all dynamic values
const resolved = resolveProps(props, dataModel);
// { children: "Alice", disabled: false }

// Or resolve individual values
const name = resolveDynamicValue({ path: "/user/name" }, dataModel);
// "Alice"`}
      lang="ts"
    />
  </ComponentSection>

  <ComponentSection>
    <h2 class="mb-4 text-2xl font-bold">Visibility Conditions</h2>
    <p class="mb-4 text-kumo-strong">
      Elements can be conditionally rendered based on data values, authentication state, or
      complex logic expressions.
    </p>
    <CodeBlock
      code={`import {
  evaluateVisibility,
  createVisibilityContext
} from "@cloudflare/kumo/catalog";

const ctx = createVisibilityContext(
  // Data model
  { user: { isAdmin: true, role: "editor" } },
  // Auth state
  { isSignedIn: true }
);

// Simple boolean
evaluateVisibility(true, ctx); // true

// Path check (truthy test)
evaluateVisibility({ path: "/user/isAdmin" }, ctx); // true

// Auth check
evaluateVisibility({ auth: "signedIn" }, ctx); // true
evaluateVisibility({ auth: "signedOut" }, ctx); // false

// Equality check
evaluateVisibility({
  eq: [{ path: "/user/role" }, "editor"]
}, ctx); // true

// Complex logic
evaluateVisibility({
  and: [
    { path: "/user/isAdmin" },
    { auth: "signedIn" },
    { gt: [{ path: "/items/length" }, 0] }
  ]
}, ctx);`}
      lang="ts"
    />
    <div class="mt-4">
      <h3 class="mb-2 text-lg font-semibold">Available Operators</h3>
      <div class="overflow-x-auto">
        <table class="min-w-full text-sm">
          <thead>
            <tr class="border-b border-kumo-line">
              <th class="py-2 pr-4 text-left font-medium">Operator</th>
              <th class="py-2 text-left font-medium">Description</th>
            </tr>
          </thead>
          <tbody class="text-kumo-strong">
            <tr class="border-b border-kumo-line">
              <td class="py-2 pr-4"><code>path</code></td>
              <td class="py-2">Truthy check on data path</td>
            </tr>
            <tr class="border-b border-kumo-line">
              <td class="py-2 pr-4"><code>auth</code></td>
              <td class="py-2">"signedIn" or "signedOut"</td>
            </tr>
            <tr class="border-b border-kumo-line">
              <td class="py-2 pr-4"><code>eq</code> / <code>neq</code></td>
              <td class="py-2">Equality / inequality comparison</td>
            </tr>
            <tr class="border-b border-kumo-line">
              <td class="py-2 pr-4"><code>gt</code> / <code>gte</code></td>
              <td class="py-2">Greater than / greater than or equal</td>
            </tr>
            <tr class="border-b border-kumo-line">
              <td class="py-2 pr-4"><code>lt</code> / <code>lte</code></td>
              <td class="py-2">Less than / less than or equal</td>
            </tr>
            <tr class="border-b border-kumo-line">
              <td class="py-2 pr-4"><code>and</code> / <code>or</code> / <code>not</code></td>
              <td class="py-2">Boolean logic combinators</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </ComponentSection>

  <ComponentSection>
    <h2 class="mb-4 text-2xl font-bold">Catalog Actions</h2>
    <p class="mb-4 text-kumo-strong">
      Elements can declare actions that your application handles. The AI describes the intent,
      and your handlers execute the logic.
    </p>
    <CodeBlock
      code={`// In your UI tree element
{
  "key": "delete-btn",
  "type": "Button",
  "props": {
    "variant": "destructive",
    "children": "Delete"
  },
  "action": {
    "name": "delete_item",
    "params": {
      "itemId": { "path": "/selected/id" }
    },
    "confirm": {
      "title": "Delete Item",
      "message": "Are you sure you want to delete this item?",
      "variant": "danger",
      "confirmLabel": "Delete",
      "cancelLabel": "Cancel"
    },
    "onSuccess": {
      "set": { "/selected": null }
    }
  }
}

// Register actions when creating the catalog
const catalog = createKumoCatalog({
  actions: {
    delete_item: {
      description: "Delete an item by ID",
      params: {
        itemId: { type: "string", description: "Item ID to delete" }
      }
    }
  }
});`}
      lang="ts"
    />
  </ComponentSection>

  <ComponentSection>
    <h2 class="mb-4 text-2xl font-bold">Validation</h2>
    <p class="mb-4 text-kumo-strong">
      The catalog validates AI-generated JSON against auto-generated Zod schemas derived from
      component TypeScript types.
    </p>
    <CodeBlock
      code={`// Validate a complete tree
const result = catalog.validateTree(aiJson);

if (result.success) {
  console.log("Valid tree:", result.data);
} else {
  console.error("Validation errors:", result.error);
  // [{ message: "Invalid enum value", path: ["elements", "btn-1", "props", "variant"] }]
}

// Validate a single element
const elementResult = catalog.validateElement({
  key: "btn-1",
  type: "Button",
  props: { variant: "primary" }
});

// Check available components
catalog.hasComponent("Button"); // true
catalog.hasComponent("Foobar"); // false

// List all component names
console.log(catalog.componentNames);
// ["Badge", "Banner", "Button", ...]`}
      lang="ts"
    />
  </ComponentSection>

  <ComponentSection>
    <h2 class="mb-4 text-2xl font-bold">Type Exports</h2>
    <p class="mb-4 text-kumo-strong">
      All types are exported for TypeScript integration:
    </p>
    <CodeBlock
      code={`import type {
  // Core types
  UIElement,
  UITree,
  DynamicValue,
  DynamicString,
  DynamicNumber,
  DynamicBoolean,

  // Visibility
  VisibilityCondition,
  LogicExpression,

  // Actions
  Action,
  ActionConfirm,
  ActionHandler,
  ActionHandlers,
  ActionDefinition,

  // Auth & Data
  AuthState,
  DataModel,

  // Catalog
  KumoCatalog,
  CatalogConfig,
  ValidationResult,
} from "@cloudflare/kumo/catalog";`}
      lang="ts"
    />
  </ComponentSection>

  <ComponentSection>
    <h2 class="mb-4 text-2xl font-bold">Key Benefits</h2>
    <div class="grid gap-4 md:grid-cols-2">
      <div class="rounded-lg border border-kumo-line bg-kumo-elevated p-4">
        <h3 class="mb-2 font-semibold">Auto-Generated Schemas</h3>
        <p class="text-sm text-kumo-strong">
          Validation schemas are derived directly from component TypeScript types.
          No separate schema definitions to maintain.
        </p>
      </div>
      <div class="rounded-lg border border-kumo-line bg-kumo-elevated p-4">
        <h3 class="mb-2 font-semibold">Always in Sync</h3>
        <p class="text-sm text-kumo-strong">
          When you update component props, the schemas update automatically via the
          component registry codegen process.
        </p>
      </div>
      <div class="rounded-lg border border-kumo-line bg-kumo-elevated p-4">
        <h3 class="mb-2 font-semibold">Streaming-Friendly</h3>
        <p class="text-sm text-kumo-strong">
          Flat tree structure enables progressive rendering as LLM responses stream in
          token-by-token.
        </p>
      </div>
      <div class="rounded-lg border border-kumo-line bg-kumo-elevated p-4">
        <h3 class="mb-2 font-semibold">Type Safety</h3>
        <p class="text-sm text-kumo-strong">
          Full TypeScript support with exported types for UIElement, UITree,
          DynamicValue, and more.
        </p>
      </div>
    </div>
  </ComponentSection>
</DocLayout>
