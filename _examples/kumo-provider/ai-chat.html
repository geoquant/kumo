<!DOCTYPE html>
<html>
<head>
    <title>AI-Powered Generative UI</title>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1rem;
        }

        .chat-container { 
            background: white; 
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 80vh;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 30px;
        }

        .message {
            margin-bottom: 20px;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message-header {
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .user-message .message-header {
            color: #667eea;
        }

        .ai-message .message-header {
            color: #764ba2;
        }

        .message-content {
            padding: 15px;
            border-radius: 12px;
            line-height: 1.6;
        }

        .user-message .message-content {
            background: #f0f4ff;
            margin-left: 40px;
        }

        .ai-message .message-content {
            background: #faf5ff;
        }

        .component-container {
            margin-top: 15px;
            padding: 20px;
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 12px;
        }

        /* Ensure Kumo components have proper spacing */
        .component-container .kumo-root {
            padding: 0 !important;
        }

        /* Smooth animations for streaming components */
        @keyframes fadeInUp {
            0% {
                opacity: 0;
                transform: translateY(20px);
            }
            100% {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Animate the LayerCard container itself */
        .component-container > div {
            animation: fadeInUp 0.4s ease-out;
        }

        /* AGGRESSIVE: Animate ALL children inside primary slot */
        /* Use view-timeline to trigger animation when elements enter viewport */
        .component-container [data-slot="primary"] > * {
            animation: fadeInUp 0.35s cubic-bezier(0.34, 1.56, 0.64, 1) backwards !important;
        }

        /* Stagger animation delays based on position */
        .component-container [data-slot="primary"] > *:nth-child(1) { animation-delay: 0.00s !important; }
        .component-container [data-slot="primary"] > *:nth-child(2) { animation-delay: 0.08s !important; }
        .component-container [data-slot="primary"] > *:nth-child(3) { animation-delay: 0.16s !important; }
        .component-container [data-slot="primary"] > *:nth-child(4) { animation-delay: 0.24s !important; }
        .component-container [data-slot="primary"] > *:nth-child(5) { animation-delay: 0.32s !important; }
        .component-container [data-slot="primary"] > *:nth-child(6) { animation-delay: 0.40s !important; }
        .component-container [data-slot="primary"] > *:nth-child(7) { animation-delay: 0.48s !important; }
        .component-container [data-slot="primary"] > *:nth-child(8) { animation-delay: 0.56s !important; }
        .component-container [data-slot="primary"] > *:nth-child(9) { animation-delay: 0.64s !important; }
        .component-container [data-slot="primary"] > *:nth-child(10) { animation-delay: 0.72s !important; }
        .component-container [data-slot="primary"] > *:nth-child(11) { animation-delay: 0.80s !important; }
        .component-container [data-slot="primary"] > *:nth-child(12) { animation-delay: 0.88s !important; }

        /* Gap utility classes */
        /* .component-container [class*="gap-"] > * + * {
            margin-top: 1rem;
        }

        .component-container [class*="gap-2"] > * + * {
            margin-top: 0.5rem;
        }

        .component-container [class*="gap-3"] > * + * {
            margin-top: 0.75rem;
        }

        .component-container [class*="gap-4"] > * + * {
            margin-top: 1rem;
        } */

        .chat-input-container {
            padding: 20px;
            background: #f8f9fa;
            border-top: 1px solid #dee2e6;
        }

        .input-wrapper {
            display: flex;
            gap: 10px;
        }

        #user-input {
            flex: 1;
            padding: 15px 20px;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            font-size: 16px;
            font-family: inherit;
            transition: border-color 0.3s;
        }

        #user-input:focus {
            outline: none;
            border-color: #667eea;
        }

        #send-button {
            padding: 15px 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        #send-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        #send-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .loading {
            display: inline-block;
            margin-left: 10px;
        }

        .loading::after {
            content: '';
            animation: ellipsis 1.5s infinite;
        }

        @keyframes ellipsis {
            0% { content: ''; }
            25% { content: '.'; }
            50% { content: '..'; }
            75% { content: '...'; }
            100% { content: ''; }
        }

        .error-message {
            background: #fff5f5;
            color: #c53030;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #fc8181;
            margin-top: 15px;
        }

        .suggestion-chips {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .chip {
            padding: 8px 16px;
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .chip:hover {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .streaming-indicator {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            color: #764ba2;
            font-size: 14px;
            font-weight: 500;
        }

        .dot-pulse {
            display: inline-flex;
            gap: 4px;
        }

        .dot-pulse span {
            width: 6px;
            height: 6px;
            background: #764ba2;
            border-radius: 50%;
            animation: pulse 1.5s ease-in-out infinite;
        }

        .dot-pulse span:nth-child(2) {
            animation-delay: 0.2s;
        }

        .dot-pulse span:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.5); opacity: 0.5; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ü§ñ AI-Powered Generative UI</h1>
            <p>Ask AI to create component interfaces in real-time</p>
            <div style="margin-top: 15px;">
                <label for="library-select" style="color: white; font-size: 0.9rem; margin-right: 10px;">Component Library:</label>
                <select id="library-select" style="padding: 8px 12px; border-radius: 8px; border: none; font-size: 1rem; cursor: pointer;">
                    <option value="http://localhost:3000/component-registry.json">Kumo (Local Registry)</option>
                    <option value="https://raw.githubusercontent.com/cloudflare/kumo/main/packages/kumo/ai/component-registry.json">Kumo (GitHub)</option>
                </select>
            </div>
            <div id="registry-status" style="margin-top: 10px; font-size: 0.9rem; opacity: 0.8;"></div>
        </div>

        <div class="chat-container">
            <div class="chat-messages" id="chat-messages">
                <div class="message ai-message">
                    <div class="message-header">
                        ü§ñ AI Assistant
                    </div>
                    <div class="message-content">
                        Hi! I can help you create Cloudflare Worker configuration interfaces. Just describe what you need, and I'll generate an interactive form for you.
                        
                        <div class="suggestion-chips">
                            <div class="chip" onclick="sendSuggestion('Create a worker configuration form')">
                                Create a worker form
                            </div>
                            <div class="chip" onclick="sendSuggestion('Show me a LayerCard with a button in it')">
                                LayerCard with button
                            </div>
                            <div class="chip" onclick="sendSuggestion('Make a deployment settings panel')">
                                Deployment settings
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="chat-input-container">
                <div class="input-wrapper">
                    <input 
                        type="text" 
                        id="user-input" 
                        placeholder="Ask me to create a component..." 
                        onkeypress="handleKeyPress(event)"
                    />
                    <button id="send-button" onclick="sendMessage()">
                        Send
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script src="./dist/kumo-bundle.umd.cjs"></script>
    <link rel="stylesheet" href="./dist/style.css">
    <!-- <script src="./public/kumo-json-overrides.js"></script> -->

    <script>
        let isStreaming = false;

        function sendSuggestion(text) {
            document.getElementById('user-input').value = text;
            sendMessage();
        }

        function handleKeyPress(event) {
            if (event.key === 'Enter' && !isStreaming) {
                sendMessage();
            }
        }

        async function sendMessage() {
            const input = document.getElementById('user-input');
            const sendButton = document.getElementById('send-button');
            const message = input.value.trim();

            if (!message || isStreaming) return;

            // Disable input
            isStreaming = true;
            input.disabled = true;
            sendButton.disabled = true;
            sendButton.textContent = 'Sending...';

            // Add user message
            addUserMessage(message);
            input.value = '';

            // Reset progressive rendering counter for new message
            window._lastRenderedCount = 0;

            // Create AI message container
            const aiMessageDiv = createAIMessage();
            const contentDiv = aiMessageDiv.querySelector('.message-content');
            
            // Add streaming indicator
            const streamingIndicator = document.createElement('div');
            streamingIndicator.className = 'streaming-indicator';
            streamingIndicator.innerHTML = `
                <div class="dot-pulse">
                    <span></span><span></span><span></span>
                </div>
                <span>AI is thinking</span>
            `;
            contentDiv.appendChild(streamingIndicator);

            try {
                // Get selected library
                const librarySelect = document.getElementById('library-select');
                const registryUrl = librarySelect.value;
                
                // Call streaming endpoint
                const response = await fetch('http://localhost:3000/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message, registryUrl })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                // Read stream
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                
                // Create component container once
                let componentContainer = null;
                let hasShownText = false;
                let progressBuffer = '';
                let lastRenderedCount = 0;
                let animationCounter = 0; // Track which render cycle we're on
                let mutationObserver = null;
                let hasEncounteredError = false; // Stop rendering if error occurs

                // Auto-scroll helper - keeps chat at bottom if user was already at bottom
                const messagesContainer = document.getElementById('chat-messages');
                const shouldAutoScroll = () => {
                    // Check if user is scrolled near the bottom (within 100px)
                    const threshold = 100;
                    const position = messagesContainer.scrollTop + messagesContainer.clientHeight;
                    const bottom = messagesContainer.scrollHeight;
                    return position >= bottom - threshold;
                };
                
                const scrollToBottom = () => {
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                };

                // Function to try parsing the buffer and extracting primary array items
                const tryExtractAndRender = () => {
                    try {
                        // Try to find and parse the primary array
                        const primaryMatch = progressBuffer.match(/"primary"\s*:\s*\[([\s\S]*)/);
                        if (!primaryMatch) return;

                        let arrayContent = primaryMatch[1];
                        
                        // Auto-complete the JSON to make it parseable
                        const openBraces = (arrayContent.match(/\{/g) || []).length;
                        const closeBraces = (arrayContent.match(/\}/g) || []).length;
                        const openBrackets = (arrayContent.match(/\[/g) || []).length;
                        const closeBrackets = (arrayContent.match(/\]/g) || []).length;
                        
                        // Close strings if needed
                        const quoteCount = (arrayContent.match(/"/g) || []).length;
                        if (quoteCount % 2 !== 0) {
                            arrayContent += '"';
                        }
                        
                        // Close brackets and braces
                        for (let i = 0; i < openBrackets - closeBrackets; i++) {
                            arrayContent += ']';
                        }
                        for (let i = 0; i < openBraces - closeBraces; i++) {
                            arrayContent += '}';
                        }
                        
                        // Close the array
                        arrayContent += ']';
                        
                        // Try to parse
                        const components = JSON.parse('[' + arrayContent);
                        
                        // Filter out incomplete components (those without a "component" property)
                        const validComponents = components.filter(c => c && c.component);
                        
                        // Only render if we have NEW valid components
                        if (validComponents.length > lastRenderedCount) {
                            console.log(`üé® NEW COMPONENT DETECTED! Rendering ${validComponents.length} components (was ${lastRenderedCount})`);
                            console.log('Valid components:', validComponents.map(c => c.component));
                            
                            // Extract secondary text
                            const secondaryMatch = progressBuffer.match(/"secondary"\s*:\s*"([^"]*)"/);
                            const secondary = secondaryMatch ? secondaryMatch[1] : '';
                            
                            const partialData = {
                                component: 'LayerCard',
                                props: {
                                    className: 'w-full',
                                    secondary: secondary,
                                    primaryClassName: 'flex flex-col gap-4',
                                    primary: validComponents
                                }
                            };
                            
                            // Check if we should auto-scroll before rendering
                            const wasAtBottom = shouldAutoScroll();
                            
                            // Render IMMEDIATELY with flushSync
                            // MutationObserver will automatically animate new nodes
                            window.CloudflareKumo.renderFromJSON(partialData, componentContainer.id);
                            lastRenderedCount = validComponents.length;
                            
                            // Auto-scroll if user was at bottom
                            if (wasAtBottom) {
                                setTimeout(scrollToBottom, 100); // Small delay to allow animation to start
                            }
                        }
                    } catch (e) {
                        // Parsing failed, buffer is still incomplete
                    }
                };

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    const text = decoder.decode(value);
                    const lines = text.split('\n');

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = JSON.parse(line.slice(6));

                            if (data.type === 'progress') {
                                // Accumulate progress for client-side parsing
                                progressBuffer += data.content;
                                
                                // Update streaming indicator
                                if (streamingIndicator.parentNode) {
                                    streamingIndicator.querySelector('span:last-child').textContent = 
                                        'AI is generating component...';
                                }
                                
                                // Remove streaming indicator after we have some content
                                if (progressBuffer.length > 50 && streamingIndicator.parentNode) {
                                    streamingIndicator.remove();
                                }
                                
                                // Create text and container if needed
                                if (!hasShownText && progressBuffer.includes('"component"')) {
                                    const textNode = document.createElement('div');
                                    textNode.textContent = "I'm creating this for you...";
                                    contentDiv.appendChild(textNode);
                                    hasShownText = true;
                                    
                                    componentContainer = document.createElement('div');
                                    componentContainer.className = 'component-container';
                                    componentContainer.id = `component-${Date.now()}`;
                                    contentDiv.appendChild(componentContainer);
                                    
                                    // Set up MutationObserver to watch for new children in primary slot
                                    mutationObserver = new MutationObserver((mutations) => {
                                        mutations.forEach((mutation) => {
                                            if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                                                mutation.addedNodes.forEach((node) => {
                                                    if (node.nodeType === 1) { // Element node
                                                        console.log('üÜï New node detected by MutationObserver:', node);
                                                        // Apply animation
                                                        node.style.opacity = '0';
                                                        node.style.transform = 'translateY(15px)';
                                                        
                                                        requestAnimationFrame(() => {
                                                            node.style.transition = 'opacity 0.3s ease-out, transform 0.35s cubic-bezier(0.34, 1.56, 0.64, 1)';
                                                            node.style.opacity = '1';
                                                            node.style.transform = 'translateY(0)';
                                                        });
                                                    }
                                                });
                                            }
                                        });
                                    });
                                    
                                    // Start observing
                                    mutationObserver.observe(componentContainer, {
                                        childList: true,
                                        subtree: true
                                    });
                                }
                                
                // AGGRESSIVE: Try to parse and render on EVERY progress event
                // This will catch new components as soon as their closing brace arrives
                if (componentContainer && !hasEncounteredError) {
                    try {
                        tryExtractAndRender();
                    } catch (error) {
                        console.error('‚ùå Error during render, stopping progressive updates:', error);
                        hasEncounteredError = true;
                    }
                }
                            } else if (data.type === 'partial') {
                                // Skip partial events if we already rendered progressively via progress events
                                if (lastRenderedCount > 0) {
                                    console.log('‚è≠Ô∏è  Skipping partial event (already rendered via progress)');
                                } else {
                                    console.log('üì• Received partial event:', data.data);
                                    
                                    // Remove streaming indicator if still present
                                    if (streamingIndicator.parentNode) {
                                        streamingIndicator.remove();
                                    }

                                    // Add response text once
                                    if (!hasShownText) {
                                        const textNode = document.createElement('div');
                                        textNode.textContent = "I'm creating this for you...";
                                        contentDiv.appendChild(textNode);
                                        hasShownText = true;
                                    }

                                    // Create component container once
                                    if (!componentContainer) {
                                        componentContainer = document.createElement('div');
                                        componentContainer.className = 'component-container';
                                        componentContainer.id = `component-${Date.now()}`;
                                        contentDiv.appendChild(componentContainer);
                                    }

                                    // Render the partial component
                                    window.CloudflareKumo.renderFromJSON(
                                        data.data,
                                        componentContainer.id
                                    );
                                }
                            } else if (data.type === 'component') {
                                // Always render the final component to ensure complete/correct data
                                const finalData = data.data;
                                const finalArrayLength = finalData.props?.primary?.length || 0;
                                
                                console.log(`üì¶ Received final component event. Array length: ${finalArrayLength}, Last rendered: ${lastRenderedCount}`);
                                
                                if (lastRenderedCount > 0 && finalArrayLength === lastRenderedCount) {
                                    // Same count, but render anyway to ensure complete props (progressive might have caught incomplete data)
                                    console.log(`üîÑ Re-rendering final component to ensure complete props`);
                                    
                                    if (!componentContainer) {
                                        componentContainer = document.createElement('div');
                                        componentContainer.className = 'component-container';
                                        componentContainer.id = `component-${Date.now()}`;
                                        contentDiv.appendChild(componentContainer);
                                    }
                                    
                                    const wasAtBottom = shouldAutoScroll();
                                    window.CloudflareKumo.renderFromJSON(
                                        finalData,
                                        componentContainer.id
                                    );
                                    if (wasAtBottom) {
                                        scrollToBottom();
                                    }
                                } else if (lastRenderedCount > 0 && finalArrayLength > lastRenderedCount) {
                                    // We rendered some items, but final has MORE - render the complete version
                                    console.log(`üîÑ Final component has ${finalArrayLength} items, we only rendered ${lastRenderedCount}. Rendering complete version.`);
                                    
                                    if (!componentContainer) {
                                        console.error('‚ö†Ô∏è Component container not found! Creating new one.');
                                        componentContainer = document.createElement('div');
                                        componentContainer.className = 'component-container';
                                        componentContainer.id = `component-${Date.now()}`;
                                        contentDiv.appendChild(componentContainer);
                                    }
                                    
                                    console.log(`Rendering to container: ${componentContainer.id}`);
                                    const wasAtBottom = shouldAutoScroll();
                                    window.CloudflareKumo.renderFromJSON(
                                        finalData,
                                        componentContainer.id
                                    );
                                    lastRenderedCount = finalArrayLength;
                                    if (wasAtBottom) {
                                        scrollToBottom();
                                    }
                                    console.log('‚úÖ Final render complete!');
                                } else {
                                    // Haven't rendered anything yet via progress, render now
                                    // Remove streaming indicator if still present
                                    if (streamingIndicator.parentNode) {
                                        streamingIndicator.remove();
                                    }

                                    // Update text to show completion
                                    if (!hasShownText) {
                                        const textNode = document.createElement('div');
                                        textNode.textContent = "I've created this for you:";
                                        contentDiv.appendChild(textNode);
                                    }

                                    // Use existing container or create new one
                                    if (!componentContainer) {
                                        componentContainer = document.createElement('div');
                                        componentContainer.className = 'component-container';
                                        componentContainer.id = `component-${Date.now()}`;
                                        contentDiv.appendChild(componentContainer);
                                    }

                                    // Render final component
                                    console.log('Rendering final component:', finalData);
                                    const wasAtBottom = shouldAutoScroll();
                                    window.CloudflareKumo.renderFromJSON(
                                        finalData,
                                        componentContainer.id
                                    );
                                    if (wasAtBottom) {
                                        scrollToBottom();
                                    }
                                }
                            } else if (data.type === 'done') {
                                console.log('‚úÖ Stream completed');
                            } else if (data.type === 'error') {
                                if (streamingIndicator.parentNode) {
                                    streamingIndicator.remove();
                                }
                                const errorDiv = document.createElement('div');
                                errorDiv.className = 'error-message';
                                errorDiv.textContent = `Error: ${data.message}`;
                                contentDiv.appendChild(errorDiv);
                            }
                        }
                    }
                }

            } catch (error) {
                console.error('Error:', error);
                streamingIndicator.remove();
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error-message';
                errorDiv.textContent = `Error: ${error.message}. Make sure the server is running on http://localhost:3000`;
                contentDiv.appendChild(errorDiv);
            } finally {
                // Re-enable input
                isStreaming = false;
                input.disabled = false;
                sendButton.disabled = false;
                sendButton.textContent = 'Send';
                input.focus();
            }
        }

        function addUserMessage(text) {
            const messagesDiv = document.getElementById('chat-messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message user-message';
            messageDiv.innerHTML = `
                <div class="message-header">üë§ You</div>
                <div class="message-content">${escapeHtml(text)}</div>
            `;
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        function createAIMessage() {
            const messagesDiv = document.getElementById('chat-messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message ai-message';
            messageDiv.innerHTML = `
                <div class="message-header">ü§ñ AI Assistant</div>
                <div class="message-content"></div>
            `;
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            return messageDiv;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Update status message based on selected library
        function updateLibraryStatus() {
            const librarySelect = document.getElementById('library-select');
            const selectedText = librarySelect.options[librarySelect.selectedIndex].text;
            const statusDiv = document.getElementById('registry-status');
            statusDiv.innerHTML = `üì¶ Ready to use <strong>${selectedText}</strong> components`;
        }

        // Focus input on load and show initial status
        window.onload = () => {
            document.getElementById('user-input').focus();
            updateLibraryStatus();
            
            // Update status when library changes
            document.getElementById('library-select').addEventListener('change', updateLibraryStatus);
        };
    </script>
</body>
</html>
