<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Kumo Cross-Boundary Demo</title>
    <link rel="stylesheet" href="/dist/loadable/style.css" />
    <style>
      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica,
          Arial, sans-serif;
        background: #f5f5f5;
        color: #1a1a1a;
        transition:
          background 0.2s,
          color 0.2s;
      }

      body[data-mode="dark"] {
        background: #1a1a1a;
        color: #f5f5f5;
      }

      .page {
        max-width: 960px;
        margin: 0 auto;
        padding: 32px 24px;
      }

      .header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 24px;
      }

      .header h1 {
        margin: 0;
        font-size: 20px;
        font-weight: 600;
      }

      .header p {
        margin: 4px 0 0;
        font-size: 13px;
        opacity: 0.6;
      }

      .presets {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 16px;
      }

      .presets button {
        padding: 4px 14px;
        font-size: 13px;
        font-weight: 500;
        border: 1px solid #ccc;
        border-radius: 16px;
        cursor: pointer;
        background: #fff;
        color: #1a1a1a;
        transition:
          background 0.15s,
          border-color 0.15s;
      }

      body[data-mode="dark"] .presets button {
        background: #2a2a2a;
        border-color: #444;
        color: #f5f5f5;
      }

      .presets button:hover:not(:disabled) {
        background: #f0f0f0;
        border-color: #f6821f;
      }

      body[data-mode="dark"] .presets button:hover:not(:disabled) {
        background: #3a3a3a;
        border-color: #f6821f;
      }

      .presets button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .controls {
        display: flex;
        gap: 8px;
        margin-bottom: 16px;
      }

      .controls input[type="text"] {
        flex: 1;
        padding: 8px 12px;
        font-size: 14px;
        border: 1px solid #ccc;
        border-radius: 6px;
        outline: none;
        background: #fff;
        color: #1a1a1a;
      }

      body[data-mode="dark"] .controls input[type="text"] {
        background: #2a2a2a;
        border-color: #444;
        color: #f5f5f5;
      }

      .controls input[type="text"]:focus {
        border-color: #f6821f;
        box-shadow: 0 0 0 2px rgba(246, 130, 31, 0.2);
      }

      /* Scope page button styles to .controls and .header so they don't
         override Tailwind @layer utilities inside #kumo-container. */
      .controls button,
      .header button {
        padding: 8px 16px;
        font-size: 14px;
        font-weight: 500;
        border: 1px solid #ccc;
        border-radius: 6px;
        cursor: pointer;
        background: #fff;
        color: #1a1a1a;
        transition:
          background 0.15s,
          border-color 0.15s;
      }

      body[data-mode="dark"] .controls button,
      body[data-mode="dark"] .header button {
        background: #2a2a2a;
        border-color: #444;
        color: #f5f5f5;
      }

      .controls button:hover:not(:disabled),
      .header button:hover:not(:disabled) {
        background: #f0f0f0;
      }

      body[data-mode="dark"] .controls button:hover:not(:disabled),
      body[data-mode="dark"] .header button:hover:not(:disabled) {
        background: #3a3a3a;
      }

      .controls button:disabled,
      .header button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .controls button.primary {
        background: #f6821f;
        border-color: #f6821f;
        color: #fff;
      }

      .controls button.primary:hover:not(:disabled) {
        background: #e0741a;
      }

      .controls button.danger {
        background: #dc3545;
        border-color: #dc3545;
        color: #fff;
      }

      .controls button.danger:hover:not(:disabled) {
        background: #c82333;
      }

      .status {
        font-size: 13px;
        margin-bottom: 12px;
        min-height: 20px;
        opacity: 0.7;
      }

      #kumo-container {
        min-height: 100px;
        border-radius: 8px;
      }

      /* ---- Conversation history ---- */

      #conversation-area {
        max-height: 70vh;
        overflow-y: auto;
      }

      #chat-history:empty {
        display: none;
      }

      .history-separator {
        border: none;
        border-top: 1px solid #ddd;
        margin: 12px 0;
      }

      body[data-mode="dark"] .history-separator {
        border-top-color: #444;
      }

      .history-user-bubble {
        display: flex;
        justify-content: flex-end;
        margin-bottom: 8px;
      }

      .history-user-bubble > div {
        max-width: 80%;
        padding: 6px 12px;
        font-size: 14px;
        border-radius: 8px;
        background: rgba(246, 130, 31, 0.12);
        color: #1a1a1a;
      }

      body[data-mode="dark"] .history-user-bubble > div {
        background: rgba(246, 130, 31, 0.2);
        color: #f5f5f5;
      }

      .history-assistant-snapshot {
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 12px;
        margin-bottom: 8px;
        opacity: 0.8;
        pointer-events: none;
      }

      body[data-mode="dark"] .history-assistant-snapshot {
        border-color: #444;
      }

      /* ---- Action event log panel ---- */

      .action-log-panel {
        margin-top: 24px;
        border: 1px solid #ddd;
        border-radius: 8px;
        overflow: hidden;
      }

      body[data-mode="dark"] .action-log-panel {
        border-color: #444;
      }

      .action-log-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 8px 12px;
        background: #eee;
        border-bottom: 1px solid #ddd;
        font-size: 13px;
        font-weight: 600;
      }

      body[data-mode="dark"] .action-log-header {
        background: #2a2a2a;
        border-bottom-color: #444;
      }

      .action-log-header button {
        padding: 2px 8px;
        font-size: 11px;
        border: 1px solid #ccc;
        border-radius: 4px;
        cursor: pointer;
        background: #fff;
        color: #1a1a1a;
      }

      body[data-mode="dark"] .action-log-header button {
        background: #333;
        border-color: #555;
        color: #f5f5f5;
      }

      .action-log-header button:hover {
        background: #f0f0f0;
      }

      body[data-mode="dark"] .action-log-header button:hover {
        background: #444;
      }

      #action-log {
        max-height: 200px;
        overflow-y: auto;
        font-family:
          "SF Mono", "Fira Code", "Fira Mono", Menlo, Consolas, monospace;
        font-size: 12px;
        line-height: 1.5;
        padding: 8px 12px;
        background: #fafafa;
      }

      body[data-mode="dark"] #action-log {
        background: #1e1e1e;
      }

      #action-log:empty::before {
        content: "No action events yet. Generate a form and interact with it.";
        opacity: 0.4;
        font-style: italic;
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica,
          Arial, sans-serif;
      }

      .action-log-entry {
        padding: 2px 0;
        border-bottom: 1px solid #eee;
        word-break: break-all;
      }

      body[data-mode="dark"] .action-log-entry {
        border-bottom-color: #333;
      }

      .action-log-entry:last-child {
        border-bottom: none;
      }

      .action-log-time {
        color: #888;
        margin-right: 8px;
      }

      .action-log-name {
        color: #f6821f;
        font-weight: 600;
      }

      .action-log-source {
        color: #888;
      }

      .action-log-detail {
        color: #666;
      }

      body[data-mode="dark"] .action-log-detail {
        color: #999;
      }
    </style>
  </head>
  <body data-mode="light">
    <div class="page">
      <div class="header">
        <div>
          <h1>Kumo Cross-Boundary Demo</h1>
          <p>
            Plain HTML &mdash; no React, no build step. Components rendered via
            UMD bundle.
          </p>
        </div>
        <button id="theme-toggle" type="button">Dark Mode</button>
      </div>

      <div id="presets" class="presets"></div>

      <div class="controls">
        <input
          id="prompt-input"
          type="text"
          placeholder="Describe a UI to generate..."
          autocomplete="off"
        />
        <button id="generate-btn" class="primary" type="button">
          Generate
        </button>
        <button id="stop-btn" class="danger" type="button" disabled>
          Stop
        </button>
        <button id="reset-btn" type="button">Reset</button>
      </div>

      <div id="status" class="status"></div>
      <div id="conversation-area">
        <div id="chat-history"></div>
        <div id="kumo-container"></div>
      </div>

      <div class="action-log-panel">
        <div class="action-log-header">
          <span>Action Events</span>
          <button id="clear-log-btn" type="button">Clear</button>
        </div>
        <div id="action-log"></div>
      </div>
    </div>

    <script src="/dist/loadable/component-loadable.umd.js"></script>
    <script>
      // =========================================================================
      // Cross-boundary streaming demo
      //
      // Reads SSE from /api/chat, feeds deltas through CloudflareKumo's JSONL
      // parser, and applies RFC 6902 patches to render kumo components
      // progressively — all without React in the host page.
      // =========================================================================

      (function () {
        "use strict";

        var CONTAINER_ID = "kumo-container";

        // -----------------------------------------------------------------------
        // DOM refs
        // -----------------------------------------------------------------------

        var promptInput = document.getElementById("prompt-input");
        var generateBtn = document.getElementById("generate-btn");
        var stopBtn = document.getElementById("stop-btn");
        var resetBtn = document.getElementById("reset-btn");
        var themeToggle = document.getElementById("theme-toggle");
        var statusEl = document.getElementById("status");
        var actionLogEl = document.getElementById("action-log");
        var clearLogBtn = document.getElementById("clear-log-btn");
        var chatHistoryEl = document.getElementById("chat-history");
        var conversationArea = document.getElementById("conversation-area");
        var presetsEl = document.getElementById("presets");

        // -----------------------------------------------------------------------
        // Preset prompts (same list as React SPA)
        // -----------------------------------------------------------------------

        var PRESET_PROMPTS = [
          "Welcome the user to Cloudflare",
          "Create a DNS record editor",
          "Show a server status dashboard",
          "Build a support ticket form",
          "Display a pricing comparison table",
          "Create a user profile settings page",
          "Show an analytics overview",
          "Build a counter",
        ];

        // -----------------------------------------------------------------------
        // State
        // -----------------------------------------------------------------------

        var abortController = null;
        var parser = null;
        var isDark = false;
        /** Conversation history for multi-turn API requests. */
        var chatHistory = [];
        /** The last user prompt, used to label history entries. */
        var lastUserMessage = "";

        // -----------------------------------------------------------------------
        // Helpers
        // -----------------------------------------------------------------------

        function setStatus(text) {
          statusEl.textContent = text;
        }

        function setStreaming(active) {
          promptInput.disabled = active;
          generateBtn.disabled = active;
          stopBtn.disabled = !active;
          var presetBtns = presetsEl.querySelectorAll("button");
          for (var i = 0; i < presetBtns.length; i++) {
            presetBtns[i].disabled = active;
          }
        }

        function formatTime() {
          var d = new Date();
          return (
            String(d.getHours()).padStart(2, "0") +
            ":" +
            String(d.getMinutes()).padStart(2, "0") +
            ":" +
            String(d.getSeconds()).padStart(2, "0") +
            "." +
            String(d.getMilliseconds()).padStart(3, "0")
          );
        }

        function appendActionLog(detail) {
          var entry = document.createElement("div");
          entry.className = "action-log-entry";

          var parts = [];
          if (detail.params) {
            parts.push("params=" + JSON.stringify(detail.params));
          }
          if (detail.context) {
            parts.push("ctx=" + JSON.stringify(detail.context));
          }
          var detailStr = parts.length > 0 ? " " + parts.join(" ") : "";

          entry.innerHTML =
            '<span class="action-log-time">' +
            formatTime() +
            "</span>" +
            '<span class="action-log-name">' +
            escapeHtml(detail.actionName) +
            "</span>" +
            ' <span class="action-log-source">from ' +
            escapeHtml(detail.sourceKey) +
            "</span>" +
            '<span class="action-log-detail">' +
            escapeHtml(detailStr) +
            "</span>";

          actionLogEl.appendChild(entry);
          actionLogEl.scrollTop = actionLogEl.scrollHeight;
        }

        function escapeHtml(str) {
          var div = document.createElement("div");
          div.appendChild(document.createTextNode(str));
          return div.innerHTML;
        }

        // -----------------------------------------------------------------------
        // Conversation history
        // -----------------------------------------------------------------------

        /** Snapshot current kumo-container content + user message into history DOM.
         *  Also tracks the *previous* turn's user+assistant pair in the API history
         *  array. The *current* user message is sent via the `message` field in the
         *  fetch body, so we must not duplicate it into `chatHistory` here. */
        function snapshotToHistory(userMessage) {
          var container = document.getElementById(CONTAINER_ID);
          var hasContent = container && container.innerHTML.trim().length > 0;

          // Archive the previous turn's user message if we have one
          if (lastUserMessage) {
            chatHistory.push({ role: "user", content: lastUserMessage });
          }

          // Append assistant snapshot if there's rendered content
          if (hasContent) {
            var snapshot = document.createElement("div");
            snapshot.className = "history-assistant-snapshot";
            snapshot.innerHTML = container.innerHTML;
            chatHistoryEl.appendChild(snapshot);

            // Track in API history array
            chatHistory.push({
              role: "assistant",
              content: "(UI response)",
            });
          }

          // Append user bubble to DOM (visual only — not pushed to chatHistory)
          var bubble = document.createElement("div");
          bubble.className = "history-user-bubble";
          var inner = document.createElement("div");
          inner.textContent = userMessage;
          bubble.appendChild(inner);
          chatHistoryEl.appendChild(bubble);
        }

        /** Scroll conversation area to bottom. */
        function scrollConversation() {
          if (conversationArea) {
            conversationArea.scrollTop = conversationArea.scrollHeight;
          }
        }

        /** Add a separator between history and current turn if history exists. */
        function addHistorySeparator() {
          // Remove existing separator
          var existing = chatHistoryEl.querySelector(".history-separator");
          if (existing) existing.remove();

          if (chatHistoryEl.children.length > 0) {
            var hr = document.createElement("hr");
            hr.className = "history-separator";
            chatHistoryEl.appendChild(hr);
          }
        }

        // -----------------------------------------------------------------------
        // SSE stream reader
        // -----------------------------------------------------------------------

        function streamChat(message) {
          // Snapshot current content into history before resetting
          snapshotToHistory(message);
          addHistorySeparator();
          lastUserMessage = message;

          // Reset previous state
          CloudflareKumo.reset(CONTAINER_ID);
          parser = CloudflareKumo.createParser();
          setStatus("Generating UI...");
          setStreaming(true);
          scrollConversation();

          abortController = new AbortController();

          fetch("/api/chat", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ message: message, history: chatHistory }),
            signal: abortController.signal,
          })
            .then(function (res) {
              if (!res.ok) {
                throw new Error("Server responded with " + res.status);
              }
              return readSSEStream(res.body);
            })
            .catch(function (err) {
              if (err.name === "AbortError") {
                setStatus("Stopped.");
              } else {
                setStatus("Error: " + err.message);
              }
              flushParser();
              cleanup();
            });
        }

        function readSSEStream(body) {
          var reader = body.getReader();
          var decoder = new TextDecoder();
          var sseBuffer = "";

          function pump() {
            return reader.read().then(function (result) {
              if (result.done) {
                flushParser();
                cleanup();
                setStatus("Done.");
                return;
              }

              sseBuffer += decoder.decode(result.value, { stream: true });

              // Split on double-newline (SSE frame boundary)
              var frames = sseBuffer.split("\n\n");
              // Last element is either empty or incomplete — keep buffered
              sseBuffer = frames.pop() || "";

              for (var i = 0; i < frames.length; i++) {
                var frame = frames[i].trim();
                if (!frame.startsWith("data: ")) continue;

                var json = frame.slice(6); // strip "data: "
                try {
                  var event = JSON.parse(json);
                } catch (_e) {
                  continue;
                }

                if (event.type === "text" && typeof event.delta === "string") {
                  var ops = parser.push(event.delta);
                  for (var j = 0; j < ops.length; j++) {
                    CloudflareKumo.applyPatch(ops[j], CONTAINER_ID);
                  }
                  scrollConversation();
                } else if (event.type === "done") {
                  flushParser();
                  cleanup();
                  setStatus("Done.");
                  scrollConversation();
                  return;
                } else if (event.type === "error") {
                  flushParser();
                  cleanup();
                  setStatus("Error: " + (event.message || "Unknown error"));
                  return;
                }
              }

              return pump();
            });
          }

          return pump();
        }

        function flushParser() {
          if (!parser) return;
          var remaining = parser.flush();
          for (var i = 0; i < remaining.length; i++) {
            CloudflareKumo.applyPatch(remaining[i], CONTAINER_ID);
          }
          parser = null;
        }

        function cleanup() {
          abortController = null;
          setStreaming(false);
        }

        // -----------------------------------------------------------------------
        // Event handlers
        // -----------------------------------------------------------------------

        generateBtn.addEventListener("click", function () {
          var text = promptInput.value.trim();
          if (!text) return;
          promptInput.value = "";
          streamChat(text);
        });

        promptInput.addEventListener("keydown", function (e) {
          if (e.key === "Enter" && !generateBtn.disabled) {
            var text = promptInput.value.trim();
            if (!text) return;
            promptInput.value = "";
            streamChat(text);
          }
        });

        stopBtn.addEventListener("click", function () {
          if (abortController) {
            abortController.abort();
            // AbortError handler in streamChat's catch will flush + cleanup
          }
        });

        resetBtn.addEventListener("click", function () {
          if (abortController) {
            abortController.abort();
            abortController = null;
          }
          parser = null;
          CloudflareKumo.reset(CONTAINER_ID);
          chatHistory = [];
          lastUserMessage = "";
          chatHistoryEl.innerHTML = "";
          setStreaming(false);
          setStatus("");
          promptInput.value = "";
        });

        themeToggle.addEventListener("click", function () {
          isDark = !isDark;
          var mode = isDark ? "dark" : "light";
          CloudflareKumo.setTheme(mode);
          themeToggle.textContent = isDark ? "Light Mode" : "Dark Mode";
        });

        // -----------------------------------------------------------------------
        // Action event log
        // -----------------------------------------------------------------------

        window.addEventListener("kumo-action", function (e) {
          var detail = e.detail;
          appendActionLog(detail);

          // Counter actions: update count-display element inline
          if (
            detail.actionName === "increment" ||
            detail.actionName === "decrement"
          ) {
            var countEl = document.querySelector('[data-key="count-display"]');
            if (countEl) {
              var current = parseInt(countEl.textContent, 10);
              if (isNaN(current)) current = 0;
              countEl.textContent = String(
                detail.actionName === "increment" ? current + 1 : current - 1,
              );
            }
          }
        });

        clearLogBtn.addEventListener("click", function () {
          actionLogEl.innerHTML = "";
        });

        // -----------------------------------------------------------------------
        // Preset prompt pills
        // -----------------------------------------------------------------------

        PRESET_PROMPTS.forEach(function (text) {
          var btn = document.createElement("button");
          btn.type = "button";
          btn.textContent = text;
          btn.addEventListener("click", function () {
            streamChat(text);
          });
          presetsEl.appendChild(btn);
        });
      })();
    </script>
  </body>
</html>
