# Progress Log
PRD: interactivity-and-exports
Started: 2026-02-19

## CRITICAL RULES
- **Branch**: ALL commits go on `geoquant/streaming-ui`. NEVER create new branches. `git checkout geoquant/streaming-ui` before any work.

## Codebase Patterns
- **Action injection pattern**: UITreeRenderer checks element.action + onAction prop to inject handlers. Button/Link get onClick; other components get onAction.
- **Spy component testing**: Real kumo components error in test env (dual React). Use `SpyComponent` + `capturedPropsMap` pattern to test prop injection. Temporarily swap COMPONENT_MAP entries in try/finally blocks.
- **createClickHandler chains existing onClick**: When injecting onClick for Button/Link, existing LLM onClick is preserved by chaining (existing fires first, then action dispatch).
- **Action registry pattern**: `dispatchAction(handlers, event, tree)` → `ActionResult | null`. Handlers return discriminated union: `patch` (RFC 6902 ops), `message` (chat content), `external` (URL navigation), `none` (no-op). `createHandlerMap(custom?)` merges with BUILTIN_HANDLERS.
- **processActionResult callbacks pattern**: `processActionResult(result, { applyPatches, sendMessage, openExternal? })`. Host provides callbacks per ActionResult variant. `openExternal` is optional (defaults to `window.open`). Use `handleSubmitRef` pattern to wire `sendMessage` to chat submission without stale closures.
- **HTML/UMD action registry**: Same handler→result→process pattern in vanilla JS. Handlers read DOM state (no tree access), return plain objects matching ActionResult shape. `processActionResult` switches on result.type to call `CloudflareKumo.applyPatch`, `streamChat`, or `window.open`.
- **Resolving kumo package dir**: `@cloudflare/kumo` has strict exports — non-exported files (e.g. `ai/component-registry.json`) can't be `require.resolve`d. Use `fs.realpathSync(path.join(PROJECT_ROOT, "node_modules/@cloudflare/kumo"))` to get real directory, then `path.join` for sub-files.

---
<!-- Task logs below - APPEND ONLY -->

## Task - renderer-1
- **Implemented**: Button/Link onClick->action bridging in UITreeRenderer. Components in `ONCLICK_ACTION_TYPES` set (Button, Link) receive `onClick` instead of `onAction` when they have an action field. Added `createClickHandler` to action-handler.ts that chains existing onClick and dispatches ActionEvent.
- **Files changed**:
  - `src/core/action-handler.ts` — added `createClickHandler` factory
  - `src/core/UITreeRenderer.tsx` — added `ONCLICK_ACTION_TYPES` set, branching logic in action injection
  - `src/__tests__/action-handler.test.ts` — 6 new tests for createClickHandler
  - `src/__tests__/ui-tree-renderer-action.test.tsx` — 7 new tests for Button/Link onClick injection
- **Learnings**: Real kumo components (Button, Link) can't render in test env due to dual React copies. Must use Spy pattern with COMPONENT_MAP swaps to test type-specific behavior.

## Task - action-1
- **Implemented**: Action handler registry (`src/core/action-registry.ts`) with `ActionHandlerMap` type, `ActionResult` discriminated union (patch | message | external | none), and `BUILTIN_HANDLERS` with increment, decrement, submit_form, navigate. Counter logic extracted from action-patch-bridge pattern. `createHandlerMap()` merges custom + builtin. `dispatchAction()` routes events through handler map.
- **Files changed**:
  - `src/core/action-registry.ts` — new file, ~200 lines
  - `src/__tests__/action-registry.test.ts` — 31 tests covering all handlers, createHandlerMap, dispatchAction
- **Learnings**: ActionResult union with 4 variants (patch, message, external, none) covers all known action patterns. Counter handlers return `PatchResult` with patches array (not single patch) for forward-compat with multi-patch actions. `submit_form` falls back from params→context for both static and runtime-collected form data.

## Task - action-2
- **Implemented**: Wired ChatDemo.tsx to use action registry instead of hardcoded `actionToPatch` bridge. `handleAction` now calls `dispatchAction(BUILTIN_HANDLERS, event, tree)` and processes the result via `processActionResult`. Extracted `processActionResult` to `src/core/process-action-result.ts` as a standalone, testable module with `ActionResultCallbacks` interface for host-provided side effects.
- **Files changed**:
  - `src/app/ChatDemo.tsx` — replaced `actionToPatch` import with `dispatchAction`/`BUILTIN_HANDLERS` from registry + `processActionResult`. Added `handleSubmitRef` for message dispatch from action results.
  - `src/core/process-action-result.ts` — new file: `processActionResult(result, callbacks)` dispatches on result.type to applyPatches/sendMessage/openExternal/none.
  - `src/__tests__/process-action-result.test.ts` — 12 tests: unit tests per result type + integration tests (registry→processor end-to-end).
- **Learnings**: Callbacks-object pattern (`ActionResultCallbacks`) is cleaner than positional args for processActionResult — extensible, self-documenting, and the `openExternal` callback can be optional with window.open fallback. The `handleSubmitRef` pattern keeps handleAction stable (no deps array changes) while allowing message dispatch to flow through the full submit pipeline.

## Task - action-3
- **Implemented**: Replaced hardcoded counter action handling in cross-boundary.html with registry pattern mirroring the TypeScript `action-registry.ts` + `process-action-result.ts`. Added `ACTION_HANDLERS` map (increment, decrement, submit_form, navigate), `dispatchActionResult()` for handler lookup, and `processActionResult()` for result processing. Counter actions produce patch results, form-submit triggers `streamChat()`, navigate opens URLs, unknown actions are logged but don't crash.
- **Files changed**:
  - `public/cross-boundary.html` — replaced inline counter logic with handler registry + dispatcher + result processor (~100 lines refactored)
- **Learnings**: HTML/UMD context lacks tree access (internal `_trees` map not exposed), so counter handlers read from DOM via `querySelector('[data-key=...]')` instead. Same ActionResult shape works cleanly in vanilla JS. The `processActionResult` in HTML directly calls `streamChat()` for message results (no ref indirection needed since there are no stale closures in vanilla JS IIFEs).

## Task - action-4
- **Implemented**: Added "Built-in Actions" subsection to system-prompt.ts with table of all 4 built-in handlers (increment, decrement, submit_form, navigate), usage examples for submit_form and navigate params, and clarification that unknown actions are logged without crash. Updated Example 4's submit button to use `submit_form` built-in with `params: { form_type: "notification_preferences" }`. Added 3 new action rules: prefer built-ins, static vs dynamic params, and context collection. Added key-points block to Example 4 explaining submit_form usage pattern.
- **Files changed**:
  - `src/core/system-prompt.ts` — added "Built-in Actions" subsection (~25 lines), 3 new rules, updated Example 4 submit button action + added key-points block (~5 lines)
- **Learnings**: System prompt structure follows a pattern: section → subsections → examples → key-points. Examples should demonstrate built-in actions where possible to guide the LLM toward patterns the host actually handles. The distinction between static `params` and runtime `context` is important for LLM guidance — LLMs should provide static metadata, not try to predict runtime values.

## Task - export-1
- **Implemented**: Added `ai/schemas` as a Vite entry point in `packages/kumo/vite.config.ts` so the build produces `dist/ai/schemas.js` (stable, non-hashed). Added `zod` (and `zod/` subpath) to the Rollup externals function so zod is not bundled — correct since it's an optional peer dependency.
- **Files changed**:
  - `packages/kumo/vite.config.ts` — added `"ai/schemas"` entry pointing to `ai/schemas.ts`, added zod to external function's switch cases
- **Learnings**: Vite entry keys like `"ai/schemas"` produce `dist/ai/schemas.js` matching the key path. The `fileName` callback `(format, entryName) => \`${entryName}.js\`` ensures stable output names. Zod must be externalized since it's an optional peer dep — bundling it would bloat the output and conflict with consumers' own zod version. The `"use client"` banner is added to all chunks including ai/schemas — harmless for non-React consumers.

## Task - export-2
- **Implemented**: Updated `packages/kumo/package.json` `./ai/schemas` export to point at compiled dist output (`dist/ai/schemas.js` + `dist/ai/schemas.d.ts`) instead of raw `.ts` source. This enables consumers to `import { ButtonSchema } from '@cloudflare/kumo/ai/schemas'` without needing a TypeScript loader.
- **Files changed**:
  - `packages/kumo/package.json` — changed `./ai/schemas` export: `types` → `./dist/ai/schemas.d.ts`, `import` → `./dist/ai/schemas.js`
- **Learnings**: The catalog's lazy `import("../../ai/schemas")` is unaffected by the package.json exports change — Vite resolves relative imports at build time to sibling paths within `dist/` (`import("./ai/schemas.js")`), not via Node.js package exports. The `vite-plugin-dts` generates `.d.ts` files in `dist/` mirroring the source structure, so `dist/ai/schemas.d.ts` is produced alongside `dist/ai/schemas.js` from the same entry point.

## Task - infra-1
- **Implemented**: Switched kumo-stream from bun to pnpm. Deleted `bun.lock`, changed `@cloudflare/kumo` dependency from `link:../../packages/kumo` to `workspace:*`, added `_examples/kumo-stream` to root `pnpm-workspace.yaml`. All scripts (`dev`, `build`, `test`, `build:loadable`, `typecheck`) work correctly under pnpm.
- **Files changed**:
  - `_examples/kumo-stream/bun.lock` — deleted
  - `_examples/kumo-stream/package.json` — `@cloudflare/kumo` changed from `link:` to `workspace:*`
  - `pnpm-workspace.yaml` — added `_examples/kumo-stream` to packages list
- **Learnings**: Switching from bun `link:` to pnpm `workspace:*` is straightforward when the project already uses standard tooling (vite, tsc, vitest, tsx) with no bun-specific APIs. pnpm creates the same symlink structure (`node_modules/@cloudflare/kumo → ../../../../packages/kumo`). No script changes needed since none referenced bun directly. The `workspace:*` protocol resolves to whatever version is in the local workspace, making it more maintainable than hardcoded `link:` paths.

## Task - wellknown-1
- **Implemented**: Added `.well-known` static routes to `server/index.ts` serving 4 endpoints: UMD bundle, component registry JSON, compiled stylesheet, and a discovery metadata endpoint. Routes resolve files from `dist/loadable/` for UMD/CSS and from the `@cloudflare/kumo` package directory (via `fs.realpathSync` on the node_modules symlink) for the registry. The discovery endpoint dynamically reads the kumo package version.
- **Files changed**:
  - `server/index.ts` — added `fs` import, `LOADABLE_DIR`/`KUMO_PKG_DIR` constants, 4 `app.get` routes for `.well-known/*`, updated startup log
- **Learnings**: `@cloudflare/kumo` has strict `exports` — `component-registry.json` is NOT an exported subpath, so `require.resolve` fails. Use `fs.realpathSync` on the `node_modules/@cloudflare/kumo` symlink to get the real package directory, then construct paths manually. Express `res.sendFile` auto-detects Content-Type from extension (`application/javascript`, `text/css`, `application/json`). The discovery endpoint reads `package.json` version at request time (not cached) — acceptable for dev server, production would cache.

## Task - wellknown-2
- **Implemented**: Updated `cross-boundary.html` to load stylesheet and UMD bundle from `.well-known` paths instead of `/dist/loadable/`. Two-line change: `href` on `<link>` tag and `src` on `<script>` tag.
- **Files changed**:
  - `public/cross-boundary.html` — stylesheet `href="/dist/loadable/style.css"` → `href="/.well-known/stylesheet.css"`, script `src="/dist/loadable/component-loadable.umd.js"` → `src="/.well-known/component-loadable.umd.js"`
- **Learnings**: Minimal integration task — the `.well-known` routes (wellknown-1) already serve the same files from `dist/loadable/`, so this is purely a path update. No functional change in behavior, just canonical URL consistency.

## Task - a11y-1
- **Implemented**: Added `## Accessibility (Required)` section to system-prompt.ts with mandatory label rules for all form elements (Input, Textarea, Checkbox, Select, Switch, RadioGroup/RadioItem). Added two DOM nesting anti-patterns to the existing anti-patterns list: no Text directly inside Banner, no block-level elements inside Text. Verified all existing examples (2, 4, 5) already comply — all Input/Select/Checkbox/Textarea elements have `label` props.
- **Files changed**:
  - `src/core/system-prompt.ts` — added 2 anti-pattern bullet points + new `## Accessibility (Required)` section (~10 lines) between Anti-Patterns and Response Format sections
- **Learnings**: System prompt structure: new top-level sections go between existing sections by importance. A11y rules belong as a dedicated section (not buried in Rules) since LLMs weight section-level headings more heavily. The counter example (Example 5) has no form elements, so no label changes needed. All existing form examples already had proper labels — the rules codify what was already best practice in the examples.

## Task - docs-1
- **Implemented**: Replaced placeholder "Streaming Responses" section in GENERATIVE-UI.md with comprehensive documentation covering: JSONL + RFC 6902 wire format, UITree target schema, concrete JSONL examples, supported operations table with RFC 6901 JSON Pointer paths, SSE transport section (server→client with frame types), and three-stage client pipeline (JSONL parser → patch application → React wiring). Includes code examples for parser interface, immutable patch application, and full React integration pattern.
- **Files changed**:
  - `_examples/GENERATIVE-UI.md` — replaced 2-line placeholder with ~120 lines of structured documentation
- **Learnings**: The streaming architecture has three clean separation boundaries worth documenting separately: (1) SSE transport (server concern — frame types, content-type headers), (2) JSONL parsing (text→structured — buffering, line splitting, tolerance of markdown fences), (3) patch application (structured→state — immutable tree updates). Each maps to a distinct module in the codebase (server/index.ts, jsonl-parser.ts, rfc6902.ts). Key behaviors to document: incremental rendering, graceful partial states (missing children don't crash), error resilience (flush preserves partial UI).

## Task - docs-2
- **Implemented**: Added "Action System" section to GENERATIVE-UI.md covering the full ActionEvent → handler registry → ActionResult → side effect pipeline. Five subsections: ActionEvent structure (with JSONL examples showing action field on elements, params vs context distinction), Component Bridging (Button/Link onClick injection vs onAction for other components), Handler Registry (ActionHandlerMap type, built-in handlers table, createHandlerMap for custom extension, dispatchAction routing), ActionResult discriminated union (all 4 variants with effects table), and Processing Results (processActionResult with callbacks pattern, full lifecycle diagram).
- **Files changed**:
  - `_examples/GENERATIVE-UI.md` — added ~130 lines as new "Action System" section after "Streaming Responses"
- **Learnings**: The action system documentation naturally decomposes into the same three-module structure as the code: (1) action-handler.ts → ActionEvent + component bridging, (2) action-registry.ts → handler map + dispatch + ActionResult types, (3) process-action-result.ts → result→callback mapping. The params/context split is the most important concept for external consumers — LLM provides static metadata, host collects runtime state. The "unknown actions return null, log but don't crash" pattern is worth calling out explicitly as a forward-compatibility guarantee.

## Task - docs-3
- **Implemented**: Updated .well-known convention section in GENERATIVE-UI.md: fixed `.umd.cjs` → `.umd.js` throughout (code block + prose), added `generative-ui.json` as fourth discovery file with example JSON response, added "Registry Hosting" subsection (serve from node_modules with `fs.realpathSync` gotcha, or re-host at build), added "Reference Implementation" subsection documenting kumo-stream as the canonical example. Also fixed one remaining `.umd.cjs` reference in the Component Response section.
- **Files changed**:
  - `_examples/GENERATIVE-UI.md` — rewrote .well-known block (3 files → 4 files), replaced single paragraph with structured bullet descriptions + discovery JSON example + registry hosting subsection + reference implementation subsection (~70 lines added/replaced), fixed `.umd.cjs` → `.umd.js` in Component Response paragraph
- **Learnings**: The original doc was written before the implementation settled on `.umd.js` (Vite UMD output). The `generative-ui.json` discovery endpoint was implemented in wellknown-1 but never documented — this fills that gap. The `fs.realpathSync` gotcha for strict package exports deserves its own callout since it's a non-obvious failure mode that `require.resolve` won't help with.
