# Progress Log
PRD: interactivity-and-exports
Started: 2026-02-19

## CRITICAL RULES
- **Branch**: ALL commits go on `geoquant/streaming-ui`. NEVER create new branches. `git checkout geoquant/streaming-ui` before any work.

## Codebase Patterns
- **Action injection pattern**: UITreeRenderer checks element.action + onAction prop to inject handlers. Button/Link get onClick; other components get onAction.
- **Spy component testing**: Real kumo components error in test env (dual React). Use `SpyComponent` + `capturedPropsMap` pattern to test prop injection. Temporarily swap COMPONENT_MAP entries in try/finally blocks.
- **createClickHandler chains existing onClick**: When injecting onClick for Button/Link, existing LLM onClick is preserved by chaining (existing fires first, then action dispatch).
- **Action registry pattern**: `dispatchAction(handlers, event, tree)` → `ActionResult | null`. Handlers return discriminated union: `patch` (RFC 6902 ops), `message` (chat content), `external` (URL navigation), `none` (no-op). `createHandlerMap(custom?)` merges with BUILTIN_HANDLERS.
- **processActionResult callbacks pattern**: `processActionResult(result, { applyPatches, sendMessage, openExternal? })`. Host provides callbacks per ActionResult variant. `openExternal` is optional (defaults to `window.open`). Use `handleSubmitRef` pattern to wire `sendMessage` to chat submission without stale closures.
- **HTML/UMD action registry**: Same handler→result→process pattern in vanilla JS. Handlers read DOM state (no tree access), return plain objects matching ActionResult shape. `processActionResult` switches on result.type to call `CloudflareKumo.applyPatch`, `streamChat`, or `window.open`.

---
<!-- Task logs below - APPEND ONLY -->

## Task - renderer-1
- **Implemented**: Button/Link onClick->action bridging in UITreeRenderer. Components in `ONCLICK_ACTION_TYPES` set (Button, Link) receive `onClick` instead of `onAction` when they have an action field. Added `createClickHandler` to action-handler.ts that chains existing onClick and dispatches ActionEvent.
- **Files changed**:
  - `src/core/action-handler.ts` — added `createClickHandler` factory
  - `src/core/UITreeRenderer.tsx` — added `ONCLICK_ACTION_TYPES` set, branching logic in action injection
  - `src/__tests__/action-handler.test.ts` — 6 new tests for createClickHandler
  - `src/__tests__/ui-tree-renderer-action.test.tsx` — 7 new tests for Button/Link onClick injection
- **Learnings**: Real kumo components (Button, Link) can't render in test env due to dual React copies. Must use Spy pattern with COMPONENT_MAP swaps to test type-specific behavior.

## Task - action-1
- **Implemented**: Action handler registry (`src/core/action-registry.ts`) with `ActionHandlerMap` type, `ActionResult` discriminated union (patch | message | external | none), and `BUILTIN_HANDLERS` with increment, decrement, submit_form, navigate. Counter logic extracted from action-patch-bridge pattern. `createHandlerMap()` merges custom + builtin. `dispatchAction()` routes events through handler map.
- **Files changed**:
  - `src/core/action-registry.ts` — new file, ~200 lines
  - `src/__tests__/action-registry.test.ts` — 31 tests covering all handlers, createHandlerMap, dispatchAction
- **Learnings**: ActionResult union with 4 variants (patch, message, external, none) covers all known action patterns. Counter handlers return `PatchResult` with patches array (not single patch) for forward-compat with multi-patch actions. `submit_form` falls back from params→context for both static and runtime-collected form data.

## Task - action-2
- **Implemented**: Wired ChatDemo.tsx to use action registry instead of hardcoded `actionToPatch` bridge. `handleAction` now calls `dispatchAction(BUILTIN_HANDLERS, event, tree)` and processes the result via `processActionResult`. Extracted `processActionResult` to `src/core/process-action-result.ts` as a standalone, testable module with `ActionResultCallbacks` interface for host-provided side effects.
- **Files changed**:
  - `src/app/ChatDemo.tsx` — replaced `actionToPatch` import with `dispatchAction`/`BUILTIN_HANDLERS` from registry + `processActionResult`. Added `handleSubmitRef` for message dispatch from action results.
  - `src/core/process-action-result.ts` — new file: `processActionResult(result, callbacks)` dispatches on result.type to applyPatches/sendMessage/openExternal/none.
  - `src/__tests__/process-action-result.test.ts` — 12 tests: unit tests per result type + integration tests (registry→processor end-to-end).
- **Learnings**: Callbacks-object pattern (`ActionResultCallbacks`) is cleaner than positional args for processActionResult — extensible, self-documenting, and the `openExternal` callback can be optional with window.open fallback. The `handleSubmitRef` pattern keeps handleAction stable (no deps array changes) while allowing message dispatch to flow through the full submit pipeline.

## Task - action-3
- **Implemented**: Replaced hardcoded counter action handling in cross-boundary.html with registry pattern mirroring the TypeScript `action-registry.ts` + `process-action-result.ts`. Added `ACTION_HANDLERS` map (increment, decrement, submit_form, navigate), `dispatchActionResult()` for handler lookup, and `processActionResult()` for result processing. Counter actions produce patch results, form-submit triggers `streamChat()`, navigate opens URLs, unknown actions are logged but don't crash.
- **Files changed**:
  - `public/cross-boundary.html` — replaced inline counter logic with handler registry + dispatcher + result processor (~100 lines refactored)
- **Learnings**: HTML/UMD context lacks tree access (internal `_trees` map not exposed), so counter handlers read from DOM via `querySelector('[data-key=...]')` instead. Same ActionResult shape works cleanly in vanilla JS. The `processActionResult` in HTML directly calls `streamChat()` for message results (no ref indirection needed since there are no stale closures in vanilla JS IIFEs).
