# Progress Log
PRD: demo-polish
Started: 2026-02-19
**Branch: `geoquant/streaming-ui`** — all work lives here. Do NOT create a separate branch.

## Codebase Patterns
- App shell: `src/app/App.tsx` wraps `<ChatDemo />` inside `kumo-root` div with `data-mode`
- Dark mode: `data-mode="light"|"dark"` on root wrapper; Kumo tokens auto-adapt via `light-dark()`
- Kumo `Button` with `variant="outline" size="sm"` for chrome controls (dark mode toggle)
- Plain HTML (`h1`, `p`) for non-interactive text; Kumo `Text` only in component rendering
- ChatDemo controls: `flex gap-2` form, Input `flex-1`, action buttons inline
- Action event wiring: `useUITree({ onAction })` → return `onAction` → pass to `UITreeRenderer onAction={onAction}`; handler creates `ActionLogEntry` with ISO timestamp
- Pre-existing lint false positives: `UITreeRenderer.tsx` lines 65/162 (semantic tokens misdetected as raw colors)
- UITree is plain data (`{ root: string, elements: Record<string, UIElement> }`), safe to `structuredClone` for snapshots
- `AssistantSnapshot` renders read-only past turns by omitting `onAction` from `UITreeRenderer`
- `ChatHistoryEntry` discriminated union: `role: "user"` has `content`, `role: "assistant"` has `tree`
- HTML/UMD history: deferred-push pattern — current user message tracked via `lastUserMessage`, archived to `chatHistory` on next turn (avoids duplication with server's `message` field)
- `pointer-events: none` on `.history-assistant-snapshot` to disable interaction in vanilla JS history

---

## Task - ui-1
- Restyled App.tsx to match cross-boundary.html layout
- Container: `max-w-[960px] p-8 px-6` (was `max-w-4xl p-8`)
- Header: flex row with h1 (text-xl font-semibold) + dark mode toggle (Kumo Button outline/sm)
- Subtitle: plain `<p>` with `text-[13px] opacity-60` (was Kumo `Text variant="secondary"`)
- Dark mode: `useState` toggle, sets `data-mode` on root wrapper
- Removed Kumo `Text` import from App.tsx (no longer needed)
- Files changed: `src/app/App.tsx`
- **Learnings:** ChatDemo controls already matched target layout (flex gap-2, Input flex-1). Only App.tsx shell needed restyling.

## Task - ui-2
- Added scrollable conversation history to React SPA
- `ChatHistoryEntry` discriminated union type for user/assistant turns
- `handleSubmit` snapshots current tree (if renderable) + user prompt into `chatHistory` before resetting
- `ChatHistoryView` renders history: `UserBubble` (right-aligned, `bg-kumo-brand-subtle`) and `AssistantSnapshot` (rendered UITree, no `onAction`)
- Scrollable container: `max-h-[70vh] overflow-y-auto` with `useEffect` auto-scroll on `[chatHistory, tree]`
- `handleReset` clears `chatHistory` alongside messages/tree
- Separator `<hr>` between history and current turn when both exist
- Files changed: `src/app/ChatDemo.tsx`
- **Learnings:** `structuredClone(tree)` works perfectly for UITree snapshots since it's plain data. Omitting `onAction` from `UITreeRenderer` is sufficient to make past turns non-interactive — no special prop needed.

## Task - ui-3
- Added scrollable conversation history + multi-turn to HTML/UMD demo
- New DOM structure: `#conversation-area` wraps `#chat-history` + `#kumo-container` with `max-height: 70vh; overflow-y: auto`
- `snapshotToHistory(msg)` archives previous turn's user+assistant pair into both DOM and `chatHistory` array
- User bubbles: `history-user-bubble` (right-aligned, orange-tinted bg); Assistant: `history-assistant-snapshot` (border, `pointer-events: none` for non-interactive)
- History separator `<hr>` between past turns and active container
- `chatHistory` array sent with each `/api/chat` request via `history` field for multi-turn
- Deferred history tracking: current user message tracked via `lastUserMessage`, pushed to `chatHistory` on *next* turn to avoid duplication (server already appends current `message`)
- Reset clears both `chatHistory = []` and `chatHistoryEl.innerHTML = ""`
- `scrollConversation()` called on new patches and completion
- Files changed: `public/cross-boundary.html`
- **Learnings:** Server appends current `message` to the messages array after iterating `history`, so `chatHistory` must NOT include the current user message — only previous turns. Using `lastUserMessage` + deferred push pattern avoids duplication. `pointer-events: none` on snapshot divs is simpler than removing event listeners for making past turns non-interactive in vanilla JS.

## Task - ui-4
- Ported preset prompt pill buttons to HTML/UMD demo
- CSS: `.presets` container (flex-wrap, gap-8px) between header and controls; pill buttons with `border-radius: 16px`, outline style, hover highlights border orange
- HTML: `<div id="presets" class="presets"></div>` between header and controls
- JS: `PRESET_PROMPTS` array matches React SPA list (7 presets); buttons created via `forEach` + `createElement`; click triggers `streamChat(text)` directly
- `setStreaming()` updated to disable/enable all preset buttons during streaming
- Dark mode styles applied via `body[data-mode="dark"] .presets button`
- Files changed: `public/cross-boundary.html`
- **Learnings:** Scoping page button styles (`.controls button`, `.header button`) was already established to avoid leaking into `#kumo-container` Tailwind classes. `.presets button` follows same pattern. Dynamic DOM creation via `forEach` + `createElement` is idiomatic for the IIFE vanilla JS style used throughout.

## Task - ui-5
- Added ActionPanel component and 2-column layout to React SPA
- New file `src/app/ActionPanel.tsx`: standalone component with `ActionLogEntry` type, `ActionLogRow` sub-component, monospace log area, auto-scroll, clear button, empty state
- Each log entry: `HH:MM:SS.mmm` timestamp + orange action name (`text-kumo-warning`) + source key + params/context detail + faded simulated `-> POST /api/actions {...}` line
- `ChatDemo.tsx`: added `actionLog` state + `handleAction` callback wired through `useUITree({ onAction })` → `UITreeRenderer onAction={onAction}`; `handleReset` and `clearActionLog` both clear the log
- 2-column layout: `flex-col md:flex-row`, left `md:w-[62%]` (chat), right `md:w-[38%]` (action panel); stacks vertically below md breakpoint
- App.tsx container widened to `md:max-w-[1400px]` (was 960px only) for 2-column space
- Files changed: `src/app/ActionPanel.tsx` (new), `src/app/ChatDemo.tsx`, `src/app/App.tsx`
- **Learnings:** `useUITree` already has `onAction` pass-through plumbing — just provide `{ onAction }` in options and thread `onAction` from the return to `UITreeRenderer`. `text-kumo-warning` is the semantic token for orange/amber text (used for action names).

## Task - functional-1
- Added `data-key={elementKey}` to all rendered elements in UITreeRenderer
- Div path: `data-key` set directly on native `<div>` element (before `filterDivProps` spread)
- Kumo component path: `data-key` added to `restProps` (spread onto `<Comp>`) — forwarded through forwardRef
- Enables `document.querySelector('[data-key="count-display"]')` for DOM identification
- Files changed: `src/core/UITreeRenderer.tsx`
- **Learnings:** `data-*` attributes pass through both `sanitizeProps` and `filterDivProps` unfiltered. Kumo forwardRef components forward unknown HTML attributes to the DOM root, so `data-key` in restProps works without wrapper divs.

## Task - functional-2
- Added Example 5 — Stateful Counter to system prompt (8 JSONL patch lines)
- Structure: Surface → Stack (centered) → heading + `count-display` (heading1) + Cluster (button row)
- Decrement button: `action: { name: "decrement" }`, variant "secondary"
- Increment button: `action: { name: "increment" }`, variant "primary"
- Count display uses key `count-display` (matches data-key from functional-1)
- Added "Key points" guidance section telling LLM that `count-display` key and `increment`/`decrement` action names are required for host-side state management
- Files changed: `src/core/system-prompt.ts`
- **Learnings:** System prompt examples follow a consistent pattern: `## Example N: Title` → `User: "prompt"` → raw JSONL lines. The "Key points" note section is a useful addition to steer the LLM toward specific key names/action names that the host application depends on.

## Task - functional-3
- Created `src/core/action-patch-bridge.ts` with `actionToPatch(event, tree)` → `JsonPatchOp | null`
- Recognizes `increment`/`decrement` actions via `COUNTER_ACTIONS` Set
- Looks up `count-display` element in tree, parses `props.children` as integer
- Returns `{ op: "replace", path: "/elements/count-display/props/children", value: String(next) }`
- Graceful fallbacks: missing element → null, non-numeric text → defaults to 0, number type children → stringified
- Created `src/__tests__/action-patch-bridge.test.ts` with 14 tests covering all edge cases
- Files changed: `src/core/action-patch-bridge.ts` (new), `src/__tests__/action-patch-bridge.test.ts` (new)
- **Learnings:** The bridge pattern (action → patch) is a clean separation: the bridge is a pure function with no side effects, making it trivially testable. `props.children` can be string or number in UIElement, so the bridge handles both. The patch path `/elements/<key>/props/children` targets the nested text content within an element.

## Task - functional-4
- Wired counter preset, onAction→actionToPatch bridge, and tree mutation into React SPA
- Added "Build a counter" to `PRESET_PROMPTS` array
- `handleAction` now calls `actionToPatch(event, tree)` and applies returned patch via `applyPatches`
- Used refs (`treeRef`, `statusRef`, `applyPatchesRef`) to avoid stale closures in the stable `handleAction` callback — refs declared before `useUITree` so the callback can close over them, synced after destructuring
- During streaming (`statusRef.current === "streaming"`), actions are logged but patches are NOT applied
- Files changed: `src/app/ChatDemo.tsx`
- **Learnings:** Circular dependency between `useCallback` and `useUITree` return values (handleAction needs `applyPatches` but is passed to `useUITree`) solved cleanly with refs: declare refs → create stable callback referencing refs → call hook → sync refs each render. The `applyPatches` from `useUITree` is stable (empty deps `useCallback`) so the ref assignment is safe.

## Task - functional-5
- Wired counter preset pill and inline DOM manipulation for count updates in HTML/UMD
- Added "Build a counter" to `PRESET_PROMPTS` array (syncs with React SPA list from functional-4)
- Extended `kumo-action` event listener: checks `detail.actionName` for `increment`/`decrement`
- Finds count element via `document.querySelector('[data-key="count-display"]')`
- Parses `textContent` as integer (`parseInt`), defaults `NaN` to 0, updates to `current ± 1`
- Action still logged to action panel via existing `appendActionLog(detail)` call (runs first)
- Files changed: `public/cross-boundary.html`
- **Learnings:** The vanilla JS counter manipulation mirrors `action-patch-bridge.ts` logic but operates directly on the DOM instead of through the patch engine. The UMD bundle's `UITreeRenderer` renders `data-key` attributes (from functional-1), so `querySelector` works without any UMD-side changes. The approach is intentionally imperative — no abstraction needed for this single use case in the vanilla demo.
