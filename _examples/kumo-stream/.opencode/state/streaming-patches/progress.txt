# Progress Log
PRD: streaming-patches
Started: 2026-02-19

## CRITICAL: Branch Rules
- **ALL work for this PRD goes on branch `geoquant/streaming-ui`** — DO NOT create new branches
- Before any commit: `git branch --show-current` must show `geoquant/streaming-ui`
- If on wrong branch: `git checkout geoquant/streaming-ui` first
- VCS is git (not jj)

## Codebase Patterns
- UIElement interface lacks index signature; use `as unknown as AnyRecord` bridge type for generic nested-path traversal
- UITree = { root: string, elements: Record<string, UIElement> } from @cloudflare/kumo/catalog
- Test runner: `pnpm test` in `_examples/kumo-stream/` (not pnpm --filter)
- Vitest globals enabled; import { describe, it, expect } from "vitest"
- Test helper pattern: `el()` factory + `tree()` factory for concise test setup
- Anthropic SDK streaming: `client.messages.stream()` → `.on('text', delta)` / `.on('finalMessage')` / `.on('error')` / `.controller.abort()`
- Vite env vars: `VITE_` prefix required, accessed via `import.meta.env.VITE_*`, needs `src/vite-env.d.ts` for TS
- kumo-stream is NOT in pnpm workspace; run commands from `_examples/kumo-stream/` dir directly

---

## Task - core-1 + testing-1
- Implemented `src/core/rfc6902.ts`: RFC 6902 subset (add/replace/remove) applied to UITree
  - `applyPatch(spec, patch)` — immutable, returns new shallow copy per call
  - `parsePatchLine(line)` — parses JSON string to JsonPatchOp, null for invalid input
  - JSON Pointer path parsing with RFC 6901 escaping (~0, ~1)
  - /- array-append convention for nested paths (e.g. /elements/card/children/-)
  - AnyRecord bridge type to handle UIElement <-> Record<string, unknown> incompatibility
- Implemented `src/__tests__/rfc6902.test.ts`: 27 tests covering all ops and edge cases
  - add /root, add /elements/{key}, add with /-, replace, remove, no-op remove, edge cases, immutability, parsePatchLine
- Files changed: `src/core/rfc6902.ts`, `src/__tests__/rfc6902.test.ts`
- **Learnings:** UIElement's interface type doesn't satisfy `Record<string, unknown>` constraint due to missing index signature. Need explicit bridge types (toRecord/toElement) for generic nested-path operations.

## Task - core-2 + testing-2
- Implemented `src/core/jsonl-parser.ts`: stateful JSONL streaming parser
  - `createJsonlParser()` returns `{ push, flush }` interface
  - `push(chunk)` buffers text, splits on `\n`, parses complete lines via `parsePatchLine`
  - `flush()` attempts to parse remaining buffer contents
  - Silently skips: empty lines, invalid JSON, markdown fences (``` prefixed)
  - Returns `readonly JsonPatchOp[]` from both push and flush
- Implemented `src/__tests__/jsonl-parser.test.ts`: 21 tests covering all verification steps
  - Single complete line, multiple lines in one chunk, line split across 2-3 chunks
  - Empty/whitespace lines skipped, invalid JSON skipped, markdown fences skipped
  - flush returns buffered incomplete line, clears buffer after flush
  - Combined push+flush workflow simulating token-by-token streaming
- Files changed: `src/core/jsonl-parser.ts`, `src/__tests__/jsonl-parser.test.ts`
- **Learnings:** Parser reuses `parsePatchLine` from rfc6902.ts — good separation of concerns. The `isSkippable` check for markdown fences needs `.trim()` since LLMs sometimes indent fence markers.

## Task - core-3
- Implemented `src/core/hooks.ts`: `useUITree()` React hook for RFC 6902 patch-driven tree state
  - Returns `{ tree, applyPatch, applyPatches, reset }` — no DataModel
  - `applyPatch(patch)` — single patch via functional setState (no stale closures)
  - `applyPatches(patches)` — folds N patches in one `setTree` call (batched render)
  - `reset()` — returns to `EMPTY_TREE` constant
  - All updaters are `useCallback`-stable references
  - Imports `applyPatch` from `rfc6902.ts` (not `patches.ts`)
- Files changed: `src/core/hooks.ts`
- **Learnings:** Explicit `UITree` annotation on functional setState params (`prev: UITree`) needed because LSP can't resolve `@cloudflare/kumo/catalog` types in dev — without it, `prev` infers as `any`.

## Task - core-4
- Rewrote `src/core/system-prompt.ts`: JSONL patch output format replaces monolithic JSON
  - Opening instruction changed from "valid JSON matching UITree schema" to "JSONL — one JSON Patch operation per line"
  - Added "Response Format: JSONL (JSON Patch)" section with op types (add/replace/remove)
  - Added "Emission Order (Strategy A — Top-Down with Upfront Children)" with 4 rules
  - Replaced monolithic JSON example with 3 complete JSONL examples (greeting, form, dashboard)
  - Anti-patterns extended: added "wrapping in markdown fences" and "emitting explanatory text"
  - All component documentation (Layout, Content, Interactive, Data Display, Navigation, Feedback) preserved verbatim
  - All design rules, design thinking, and anti-patterns preserved
- Files changed: `src/core/system-prompt.ts`
- **Learnings:** Strategy A (children array declared upfront in parent element) is key for streaming — the renderer can reference child keys before child elements exist, which pairs with functional-2's "render missing keys as null" behavior.

## Task - functional-1
- Created `src/core/stream-client.ts`: Anthropic SDK streaming wrapper
  - `startStream(config, messages, callbacks)` returns `StreamHandle` with `abort()`
  - Wraps `client.messages.stream()` with `on('text')`, `on('finalMessage')`, `on('error')`
  - `dangerouslyAllowBrowser: true` for client-side demo (non-production)
  - Uses `SYSTEM_PROMPT` from system-prompt.ts, configurable model via env
- Created `src/app/ChatDemo.tsx`: main streaming UI chat interface
  - Uses `useUITree()` hook (not raw `useState<UITree>`)
  - Creates fresh `createJsonlParser()` per stream in `parserRef`
  - `onText` → `parser.push(delta)` → `applyPatches(ops)` for incremental rendering
  - `onDone` → `parser.flush()` → `applyPatches(remaining)` for final buffer
  - `reset()` + new parser on each new message; full reset clears conversation history
  - Stop button aborts stream, flushes partial content so it stays visible
  - 7 preset prompts, freeform input, error display for missing API key
  - `extractUITree` not imported — fully replaced by JSONL pipeline
- Created `src/vite-env.d.ts`: Vite ImportMeta type declarations for `VITE_ANTHROPIC_API_KEY`
- Updated `src/app/App.tsx`: renders `ChatDemo` with page chrome
- Files changed: `src/core/stream-client.ts`, `src/app/ChatDemo.tsx`, `src/app/App.tsx`, `src/vite-env.d.ts`
- **Learnings:** Anthropic SDK's `MessageStream` uses `.on('text', (delta, snapshot))` for deltas and `.on('finalMessage', (msg))` for completion. The `stream.controller.abort()` is the cancellation mechanism. `dangerouslyAllowBrowser: true` required for client-side usage.

## Task - functional-2
- Added `streaming` prop to `UITreeRenderer` and `RenderElement` — when true, missing element keys render as `null` (invisible) instead of error divs
- During streaming, parent elements declare children arrays before child elements arrive (Strategy A); this prevents red "Missing element" errors from flashing
- After streaming completes (`streaming=false`, the default), missing keys revert to error rendering for debugging
- Updated `ChatDemo.tsx` to pass `streaming={isStreaming}` to `UITreeRenderer`
- Files changed: `src/core/UITreeRenderer.tsx`, `src/app/ChatDemo.tsx`
- **Learnings:** The `streaming` prop propagates through recursive `RenderElement` calls. A simple boolean prop is sufficient — no need for React context since the prop is already threaded through the render tree. Default `false` preserves backward compatibility.

## Task - cleanup-1
- Deleted `src/core/patches.ts` (custom UITreePatch system — add/replace/remove/batch)
- Deleted `src/__tests__/patches.test.ts` (all tests for the custom patch system)
- Verified zero remaining imports of `patches.ts` anywhere in codebase
- TypeScript compiles clean, all 48 tests pass (rfc6902 + jsonl-parser)
- Files deleted: `src/core/patches.ts`, `src/__tests__/patches.test.ts`
- **Learnings:** Clean deletion — no other module depended on patches.ts. The RFC 6902 replacement (rfc6902.ts) was already fully wired in prior tasks, so this was purely dead code removal.

## Task - testing-3
- Implemented `src/__tests__/streaming-integration.test.ts`: 8 tests across 4 describe blocks
  - Token-by-token delivery: small chunks (10 char), single-char, whole-line — all produce correct final tree
  - Incremental growth: verifies tree shape at each stage (empty → root → card → heading → text)
  - Final tree verification: chunked vs whole-line delivery produce identical results; element relationships correct
  - Complex UI: dashboard layout with 5 elements, monotonically growing element count; replace op mid-stream
- Pure data-layer integration test — exercises createJsonlParser + applyPatch pipeline without React
- `tokenize()` helper splits JSONL response into fixed-size chunks to simulate LLM streaming tokenizer
- `foldPatches()` helper mirrors the fold logic from `useUITree.applyPatches` in hooks.ts
- Files changed: `src/__tests__/streaming-integration.test.ts`
- **Learnings:** The parser + patch pipeline is deterministic — chunk size doesn't affect final result, only the number of intermediate snapshots. `tokenize` with odd chunk sizes (7, 13) reliably splits mid-JSON, proving the parser's buffering correctness.

## Task - regression-1
- Implemented `src/__tests__/regression.test.ts`: 40 tests across 5 describe blocks
  - **7 preset fixtures**: realistic JSONL for all preset categories (Welcome, DNS Editor, Dashboard, Support Ticket, Pricing Table, Settings, Analytics) — each verified for renderability, child reference resolution, and known component types
  - **Multi-turn**: sequential turns produce independent trees, no state leakage between turns, message history accumulates correctly
  - **Stop/abort**: partial delivery after N lines yields valid partial tree; root-only not renderable; all delivered elements preserved; flush after incomplete line handled gracefully
  - **Error states**: missing/empty API key detection, error mid-stream preserves partial tree (flush-before-error pattern), error on first token → empty tree, malformed JSONL (bad JSON, markdown fences, truncated) silently tolerated
  - **isRenderableTree contract**: empty tree, root-only, elements-only, complete tree
- All 96 tests pass (56 existing + 40 new), TypeScript clean
- Files changed: `src/__tests__/regression.test.ts`
- **Learnings:** `simulateStream()` and `simulatePartialStream()` helpers provide a clean abstraction for testing the full pipeline without React or network. `resolveApiKey()` extracted to avoid TS narrowing `never` on constant `undefined` values.
